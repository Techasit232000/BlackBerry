<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlackBerry Dynamics: Crypto C Programming Interface List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen_13.1.0.48.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra_13.1.0.48.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="titleheadings">
	<ul> 
		<li id="projectlogo">
	 		<a id="corplink" href="https://blackberry.com/"><img alt="Logo" src="BlackBerryLogo.png"/></a></li>
	 	<li id="projectname">BlackBerry Dynamics</li>
	  	<li id="projectbrief">Runtime library for iOS applications</li>
	  	<li id="projectnumber">13.1.0.48</li>
	 </ul>
	</div>
	 <div id="titlelinks">
	 		<a href="https://developers.blackberry.com">BlackBerry Developers</a>
	 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__cryptolist.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Crypto C Programming Interface List</div>  </div>
</div><!--header-->
<div class="contents">

<p>This page lists the elements of the BlackBerry Dynamics Crypto C language programming interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7cc648bc0c2646f957083936fe50b572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7cc648bc0c2646f957083936fe50b572">GD_C_API_EXT</a></td></tr>
<tr class="separator:ga7cc648bc0c2646f957083936fe50b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc648bc0c2646f957083936fe50b572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7cc648bc0c2646f957083936fe50b572">GD_C_API_EXT</a></td></tr>
<tr class="separator:ga7cc648bc0c2646f957083936fe50b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc648bc0c2646f957083936fe50b572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7cc648bc0c2646f957083936fe50b572">GD_C_API_EXT</a></td></tr>
<tr class="separator:ga7cc648bc0c2646f957083936fe50b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc648bc0c2646f957083936fe50b572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7cc648bc0c2646f957083936fe50b572">GD_C_API_EXT</a></td></tr>
<tr class="separator:ga7cc648bc0c2646f957083936fe50b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc648bc0c2646f957083936fe50b572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7cc648bc0c2646f957083936fe50b572">GD_C_API_EXT</a></td></tr>
<tr class="separator:ga7cc648bc0c2646f957083936fe50b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc648bc0c2646f957083936fe50b572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7cc648bc0c2646f957083936fe50b572">GD_C_API_EXT</a></td></tr>
<tr class="separator:ga7cc648bc0c2646f957083936fe50b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf1f0c793448eb52d749d19da7ab13b3a"><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaf1f0c793448eb52d749d19da7ab13b3a">GDCipher_list</a> (void)</td></tr>
<tr class="memdesc:gaf1f0c793448eb52d749d19da7ab13b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all cipher suites by name.  <a href="group__cryptolist.html#gaf1f0c793448eb52d749d19da7ab13b3a">More...</a><br /></td></tr>
<tr class="separator:gaf1f0c793448eb52d749d19da7ab13b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b321016f22f16f58b65b91bc2a638d0"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4b321016f22f16f58b65b91bc2a638d0">GDCipher_byname</a> (const char *name)</td></tr>
<tr class="memdesc:ga4b321016f22f16f58b65b91bc2a638d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cipher suite by name.  <a href="group__cryptolist.html#ga4b321016f22f16f58b65b91bc2a638d0">More...</a><br /></td></tr>
<tr class="separator:ga4b321016f22f16f58b65b91bc2a638d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e78a0c799468f822b92b7d6aa33720"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga86e78a0c799468f822b92b7d6aa33720">GDCipher_name</a> (const struct GDCipherContext *ctx)</td></tr>
<tr class="memdesc:ga86e78a0c799468f822b92b7d6aa33720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cipher suite's name.  <a href="group__cryptolist.html#ga86e78a0c799468f822b92b7d6aa33720">More...</a><br /></td></tr>
<tr class="separator:ga86e78a0c799468f822b92b7d6aa33720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7114a8ba37699855bcdfa5537d0253"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gabf7114a8ba37699855bcdfa5537d0253">GDCipher_bycontext</a> (const struct GDCipherContext *ctx)</td></tr>
<tr class="memdesc:gabf7114a8ba37699855bcdfa5537d0253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cipher by context.  <a href="group__cryptolist.html#gabf7114a8ba37699855bcdfa5537d0253">More...</a><br /></td></tr>
<tr class="separator:gabf7114a8ba37699855bcdfa5537d0253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136b15c1b82ead844e8a219c78e6a241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga136b15c1b82ead844e8a219c78e6a241">GDCipher_block_size</a> (const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *cipher)</td></tr>
<tr class="memdesc:ga136b15c1b82ead844e8a219c78e6a241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cipher block size.  <a href="group__cryptolist.html#ga136b15c1b82ead844e8a219c78e6a241">More...</a><br /></td></tr>
<tr class="separator:ga136b15c1b82ead844e8a219c78e6a241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ff9d13cb230d81d7734f5bd6c65981"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga40ff9d13cb230d81d7734f5bd6c65981">GDCipher_key_length</a> (const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *cipher)</td></tr>
<tr class="memdesc:ga40ff9d13cb230d81d7734f5bd6c65981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cipher key length.  <a href="group__cryptolist.html#ga40ff9d13cb230d81d7734f5bd6c65981">More...</a><br /></td></tr>
<tr class="separator:ga40ff9d13cb230d81d7734f5bd6c65981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fd4f95055f8cb9854ffa6212db5f43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab9fd4f95055f8cb9854ffa6212db5f43">GDCipher_iv_length</a> (const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *cipher)</td></tr>
<tr class="memdesc:gab9fd4f95055f8cb9854ffa6212db5f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the IV length.  <a href="group__cryptolist.html#gab9fd4f95055f8cb9854ffa6212db5f43">More...</a><br /></td></tr>
<tr class="separator:gab9fd4f95055f8cb9854ffa6212db5f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e41fcc79af459361b3cf04e64eab9a8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga5e41fcc79af459361b3cf04e64eab9a8">GDCipher_mode</a> (const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *cipher)</td></tr>
<tr class="memdesc:ga5e41fcc79af459361b3cf04e64eab9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cipher mode.  <a href="group__cryptolist.html#ga5e41fcc79af459361b3cf04e64eab9a8">More...</a><br /></td></tr>
<tr class="separator:ga5e41fcc79af459361b3cf04e64eab9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c668c5c417c5cc22bcd299ebe3828e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab4c668c5c417c5cc22bcd299ebe3828e">GDCipher_set_padding</a> (struct GDCipherContext *ctx, int padding)</td></tr>
<tr class="memdesc:gab4c668c5c417c5cc22bcd299ebe3828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable padding.  <a href="group__cryptolist.html#gab4c668c5c417c5cc22bcd299ebe3828e">More...</a><br /></td></tr>
<tr class="separator:gab4c668c5c417c5cc22bcd299ebe3828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10008504f2c7e42fe0c77724632e0916"><td class="memItemLeft" align="right" valign="top">struct GDCipherContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga10008504f2c7e42fe0c77724632e0916">GDCipher_new</a> (void)</td></tr>
<tr class="memdesc:ga10008504f2c7e42fe0c77724632e0916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new cipher context.  <a href="group__cryptolist.html#ga10008504f2c7e42fe0c77724632e0916">More...</a><br /></td></tr>
<tr class="separator:ga10008504f2c7e42fe0c77724632e0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7bc56282236fdf8b540d775c0eb4c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gace7bc56282236fdf8b540d775c0eb4c7">GDCipher_init</a> (struct GDCipherContext *ctx, const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *cipher, const void *key, const void *iv, int mode)</td></tr>
<tr class="memdesc:gace7bc56282236fdf8b540d775c0eb4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a cipher context.  <a href="group__cryptolist.html#gace7bc56282236fdf8b540d775c0eb4c7">More...</a><br /></td></tr>
<tr class="separator:gace7bc56282236fdf8b540d775c0eb4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab170558ce35f874c1b83fa5824078df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab170558ce35f874c1b83fa5824078df4">GDCipher_copy</a> (struct GDCipherContext *destination, const struct GDCipherContext *source)</td></tr>
<tr class="memdesc:gab170558ce35f874c1b83fa5824078df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a cipher context.  <a href="group__cryptolist.html#gab170558ce35f874c1b83fa5824078df4">More...</a><br /></td></tr>
<tr class="separator:gab170558ce35f874c1b83fa5824078df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50e1927901f05be82921d285422c405"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae50e1927901f05be82921d285422c405">GDCipher_update</a> (struct GDCipherContext *ctx, void *out_data, int *out_data_sz, const void *in_data, int in_data_sz)</td></tr>
<tr class="memdesc:gae50e1927901f05be82921d285422c405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encipher or decipher.  <a href="group__cryptolist.html#gae50e1927901f05be82921d285422c405">More...</a><br /></td></tr>
<tr class="separator:gae50e1927901f05be82921d285422c405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b831846627eff0e346332b615a84f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga78b831846627eff0e346332b615a84f3">GDCipher_final</a> (struct GDCipherContext *ctx, void *out_data, int *out_sz)</td></tr>
<tr class="memdesc:ga78b831846627eff0e346332b615a84f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encipher or decipher last block.  <a href="group__cryptolist.html#ga78b831846627eff0e346332b615a84f3">More...</a><br /></td></tr>
<tr class="separator:ga78b831846627eff0e346332b615a84f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ce23781acaeef6afa376c4b7983398"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> (struct GDCipherContext *ctx, void *out_data, const void *in_data, unsigned int in_data_sz)</td></tr>
<tr class="memdesc:ga76ce23781acaeef6afa376c4b7983398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encipher or decipher.  <a href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">More...</a><br /></td></tr>
<tr class="separator:ga76ce23781acaeef6afa376c4b7983398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada41794300643ff312c31d5b7fdcecec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gada41794300643ff312c31d5b7fdcecec">GDCipher_cleanup</a> (struct GDCipherContext *ctx)</td></tr>
<tr class="memdesc:gada41794300643ff312c31d5b7fdcecec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all information from a cipher context.  <a href="group__cryptolist.html#gada41794300643ff312c31d5b7fdcecec">More...</a><br /></td></tr>
<tr class="separator:gada41794300643ff312c31d5b7fdcecec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1bcce9e8c309f54807d2345a7533ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae1bcce9e8c309f54807d2345a7533ace">GDCipher_free</a> (struct GDCipherContext *ctx)</td></tr>
<tr class="memdesc:gae1bcce9e8c309f54807d2345a7533ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the cipher context.  <a href="group__cryptolist.html#gae1bcce9e8c309f54807d2345a7533ace">More...</a><br /></td></tr>
<tr class="separator:gae1bcce9e8c309f54807d2345a7533ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad071d12fb3d072441ad058fb3934293e"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad071d12fb3d072441ad058fb3934293e">GDDigest_byname</a> (const char *name)</td></tr>
<tr class="memdesc:gad071d12fb3d072441ad058fb3934293e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a digest algorithm by name.  <a href="group__cryptolist.html#gad071d12fb3d072441ad058fb3934293e">More...</a><br /></td></tr>
<tr class="separator:gad071d12fb3d072441ad058fb3934293e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d464d593efe47baf9b68cc6906cf5f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga11d464d593efe47baf9b68cc6906cf5f">GDDigest_name</a> (const struct GDDigestContext *ctx)</td></tr>
<tr class="memdesc:ga11d464d593efe47baf9b68cc6906cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a digest's name.  <a href="group__cryptolist.html#ga11d464d593efe47baf9b68cc6906cf5f">More...</a><br /></td></tr>
<tr class="separator:ga11d464d593efe47baf9b68cc6906cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ba8398be10277e296a6dba119a0126"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaf8ba8398be10277e296a6dba119a0126">GDDigest_bycontext</a> (const struct GDDigestContext *ctx)</td></tr>
<tr class="memdesc:gaf8ba8398be10277e296a6dba119a0126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a digest by context.  <a href="group__cryptolist.html#gaf8ba8398be10277e296a6dba119a0126">More...</a><br /></td></tr>
<tr class="separator:gaf8ba8398be10277e296a6dba119a0126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b33c5aaf906165060a7c9d5cefa4f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga83b33c5aaf906165060a7c9d5cefa4f6">GDDigest_size</a> (const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest)</td></tr>
<tr class="memdesc:ga83b33c5aaf906165060a7c9d5cefa4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a digest in bytes.  <a href="group__cryptolist.html#ga83b33c5aaf906165060a7c9d5cefa4f6">More...</a><br /></td></tr>
<tr class="separator:ga83b33c5aaf906165060a7c9d5cefa4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb3ee6e8ee908ba72a96d4235685388"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaccb3ee6e8ee908ba72a96d4235685388">GDDigest_block_size</a> (const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest)</td></tr>
<tr class="memdesc:gaccb3ee6e8ee908ba72a96d4235685388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the digest block size.  <a href="group__cryptolist.html#gaccb3ee6e8ee908ba72a96d4235685388">More...</a><br /></td></tr>
<tr class="separator:gaccb3ee6e8ee908ba72a96d4235685388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990ac7fb4c04ee68da737ae8ee920a54"><td class="memItemLeft" align="right" valign="top">struct GDDigestContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga990ac7fb4c04ee68da737ae8ee920a54">GDDigest_new</a> (void)</td></tr>
<tr class="memdesc:ga990ac7fb4c04ee68da737ae8ee920a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new digest context.  <a href="group__cryptolist.html#ga990ac7fb4c04ee68da737ae8ee920a54">More...</a><br /></td></tr>
<tr class="separator:ga990ac7fb4c04ee68da737ae8ee920a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50948df9ca3607ccccad176e8e2fce1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa50948df9ca3607ccccad176e8e2fce1">GDDigest_init</a> (struct GDDigestContext *ctx, const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *algorithm)</td></tr>
<tr class="memdesc:gaa50948df9ca3607ccccad176e8e2fce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a digest context.  <a href="group__cryptolist.html#gaa50948df9ca3607ccccad176e8e2fce1">More...</a><br /></td></tr>
<tr class="separator:gaa50948df9ca3607ccccad176e8e2fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01595eda382b2bb3c4e4013f01f985d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga01595eda382b2bb3c4e4013f01f985d1">GDDigest_copy</a> (struct GDDigestContext *destination, const struct GDDigestContext *source)</td></tr>
<tr class="memdesc:ga01595eda382b2bb3c4e4013f01f985d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a digest context.  <a href="group__cryptolist.html#ga01595eda382b2bb3c4e4013f01f985d1">More...</a><br /></td></tr>
<tr class="separator:ga01595eda382b2bb3c4e4013f01f985d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12bd434ec509eb679e02a6795581d2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae12bd434ec509eb679e02a6795581d2a">GDDigest_update</a> (struct GDDigestContext *ctx, const void *message, size_t message_sz)</td></tr>
<tr class="memdesc:gae12bd434ec509eb679e02a6795581d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a digest.  <a href="group__cryptolist.html#gae12bd434ec509eb679e02a6795581d2a">More...</a><br /></td></tr>
<tr class="separator:gae12bd434ec509eb679e02a6795581d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa71b7654927012982e6a477dc3ecb844"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa71b7654927012982e6a477dc3ecb844">GDDigest_final</a> (struct GDDigestContext *ctx, void *digest, unsigned int *digest_sz)</td></tr>
<tr class="memdesc:gaa71b7654927012982e6a477dc3ecb844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and output the digest.  <a href="group__cryptolist.html#gaa71b7654927012982e6a477dc3ecb844">More...</a><br /></td></tr>
<tr class="separator:gaa71b7654927012982e6a477dc3ecb844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88753feb89e59dd74163c293c4ec8d83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> (const void *data, size_t data_sz, void *md, unsigned int *md_sz, const struct GDDigest *type)</td></tr>
<tr class="memdesc:ga88753feb89e59dd74163c293c4ec8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a digest.  <a href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">More...</a><br /></td></tr>
<tr class="separator:ga88753feb89e59dd74163c293c4ec8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e89a3fa76754ee4a081ebfdcd726e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad0e89a3fa76754ee4a081ebfdcd726e1">GDDigest_sign_init</a> (struct GDDigestContext *ctx, struct GDKeyContext **key_context, const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest, struct GDKey *key)</td></tr>
<tr class="memdesc:gad0e89a3fa76754ee4a081ebfdcd726e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a digest context for signing.  <a href="group__cryptolist.html#gad0e89a3fa76754ee4a081ebfdcd726e1">More...</a><br /></td></tr>
<tr class="separator:gad0e89a3fa76754ee4a081ebfdcd726e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbfe65af0dc09e5b25b68be7272220eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gacbfe65af0dc09e5b25b68be7272220eb">GDDigest_sign_final</a> (struct GDDigestContext *ctx, void *signature, size_t *signature_sz)</td></tr>
<tr class="memdesc:gacbfe65af0dc09e5b25b68be7272220eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a digest.  <a href="group__cryptolist.html#gacbfe65af0dc09e5b25b68be7272220eb">More...</a><br /></td></tr>
<tr class="separator:gacbfe65af0dc09e5b25b68be7272220eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c574cbd428f62f2a21f450ed8606a66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga9c574cbd428f62f2a21f450ed8606a66">GDDigest_verify_init</a> (struct GDDigestContext *ctx, struct GDKeyContext **key_ctx, const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest, struct GDKey *key)</td></tr>
<tr class="memdesc:ga9c574cbd428f62f2a21f450ed8606a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a digest context for verification.  <a href="group__cryptolist.html#ga9c574cbd428f62f2a21f450ed8606a66">More...</a><br /></td></tr>
<tr class="separator:ga9c574cbd428f62f2a21f450ed8606a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627c39856bae844c89ef6c010e05f91a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga627c39856bae844c89ef6c010e05f91a">GDDigest_verify_final</a> (struct GDDigestContext *ctx, const void *signature, size_t signature_sz)</td></tr>
<tr class="memdesc:ga627c39856bae844c89ef6c010e05f91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a digest.  <a href="group__cryptolist.html#ga627c39856bae844c89ef6c010e05f91a">More...</a><br /></td></tr>
<tr class="separator:ga627c39856bae844c89ef6c010e05f91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e79b75925417b9615d420bbfa89629"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga02e79b75925417b9615d420bbfa89629">GDDigest_cleanup</a> (struct GDDigestContext *ctx)</td></tr>
<tr class="memdesc:ga02e79b75925417b9615d420bbfa89629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all information from a digest context.  <a href="group__cryptolist.html#ga02e79b75925417b9615d420bbfa89629">More...</a><br /></td></tr>
<tr class="separator:ga02e79b75925417b9615d420bbfa89629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e7a9cd1a9642506442675e8d8ba04b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga98e7a9cd1a9642506442675e8d8ba04b">GDDigest_free</a> (struct GDDigestContext *ctx)</td></tr>
<tr class="memdesc:ga98e7a9cd1a9642506442675e8d8ba04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the digest context.  <a href="group__cryptolist.html#ga98e7a9cd1a9642506442675e8d8ba04b">More...</a><br /></td></tr>
<tr class="separator:ga98e7a9cd1a9642506442675e8d8ba04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1603708f721422f770341800d8a00008"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008">GDCryptoError_get</a> (void)</td></tr>
<tr class="memdesc:ga1603708f721422f770341800d8a00008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the earliest error code.  <a href="group__cryptolist.html#ga1603708f721422f770341800d8a00008">More...</a><br /></td></tr>
<tr class="separator:ga1603708f721422f770341800d8a00008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f40984b35d40779b302f0e4356bb62a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1f40984b35d40779b302f0e4356bb62a">GDCryptoError_peek</a> (void)</td></tr>
<tr class="memdesc:ga1f40984b35d40779b302f0e4356bb62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the earliest error code.  <a href="group__cryptolist.html#ga1f40984b35d40779b302f0e4356bb62a">More...</a><br /></td></tr>
<tr class="separator:ga1f40984b35d40779b302f0e4356bb62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ff150afbef5e9f3879bce5f81d79be"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad3ff150afbef5e9f3879bce5f81d79be">GDCryptoError_peek_last</a> (void)</td></tr>
<tr class="memdesc:gad3ff150afbef5e9f3879bce5f81d79be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest error code.  <a href="group__cryptolist.html#gad3ff150afbef5e9f3879bce5f81d79be">More...</a><br /></td></tr>
<tr class="separator:gad3ff150afbef5e9f3879bce5f81d79be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ba8f1303ac100812693cb5841a56ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa8ba8f1303ac100812693cb5841a56ee">GDCryptoError_clear</a> (void)</td></tr>
<tr class="memdesc:gaa8ba8f1303ac100812693cb5841a56ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the error stack.  <a href="group__cryptolist.html#gaa8ba8f1303ac100812693cb5841a56ee">More...</a><br /></td></tr>
<tr class="separator:gaa8ba8f1303ac100812693cb5841a56ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33eb1f64dc931bf5edcc2d8c65fc1081"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga33eb1f64dc931bf5edcc2d8c65fc1081">GDCryptoError_string</a> (unsigned long e)</td></tr>
<tr class="memdesc:ga33eb1f64dc931bf5edcc2d8c65fc1081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable string representing the error code.  <a href="group__cryptolist.html#ga33eb1f64dc931bf5edcc2d8c65fc1081">More...</a><br /></td></tr>
<tr class="separator:ga33eb1f64dc931bf5edcc2d8c65fc1081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39eea112baae1cf8dad0a7836ca6047"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad39eea112baae1cf8dad0a7836ca6047">GDCryptoError_detailed_string</a> (void)</td></tr>
<tr class="memdesc:gad39eea112baae1cf8dad0a7836ca6047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a detailed human-readable string of the last error.  <a href="group__cryptolist.html#gad39eea112baae1cf8dad0a7836ca6047">More...</a><br /></td></tr>
<tr class="separator:gad39eea112baae1cf8dad0a7836ca6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c98f717b0c30fc44c739f7b969466b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga2c98f717b0c30fc44c739f7b969466b5">GDFIPS_mode</a> (void)</td></tr>
<tr class="memdesc:ga2c98f717b0c30fc44c739f7b969466b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current FIPS 140-2 mode of operation.  <a href="group__cryptolist.html#ga2c98f717b0c30fc44c739f7b969466b5">More...</a><br /></td></tr>
<tr class="separator:ga2c98f717b0c30fc44c739f7b969466b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817dd75ea1ca9b7a5228666ac08a13d1"><td class="memItemLeft" align="right" valign="top">struct GDX509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga817dd75ea1ca9b7a5228666ac08a13d1">GDX509_copy</a> (const struct GDX509 *cert)</td></tr>
<tr class="memdesc:ga817dd75ea1ca9b7a5228666ac08a13d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a X509 structure.  <a href="group__cryptolist.html#ga817dd75ea1ca9b7a5228666ac08a13d1">More...</a><br /></td></tr>
<tr class="separator:ga817dd75ea1ca9b7a5228666ac08a13d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603ad0c14f7b24613f7325234c5b3bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga603ad0c14f7b24613f7325234c5b3bd6">GDX509_free</a> (struct GDX509 *cert)</td></tr>
<tr class="memdesc:ga603ad0c14f7b24613f7325234c5b3bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a X509 structure.  <a href="group__cryptolist.html#ga603ad0c14f7b24613f7325234c5b3bd6">More...</a><br /></td></tr>
<tr class="separator:ga603ad0c14f7b24613f7325234c5b3bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e2d56061f2544a2171c751b381c37d9"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4e2d56061f2544a2171c751b381c37d9">GDX509List_read</a> (const char *pem, int pem_length)</td></tr>
<tr class="memdesc:ga4e2d56061f2544a2171c751b381c37d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of X509 certificates within a PEM container.  <a href="group__cryptolist.html#ga4e2d56061f2544a2171c751b381c37d9">More...</a><br /></td></tr>
<tr class="separator:ga4e2d56061f2544a2171c751b381c37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5625e7158a7c606620842395e991dd5"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa5625e7158a7c606620842395e991dd5">GDX509List_copy</a> (const struct GDX509List *certs)</td></tr>
<tr class="memdesc:gaa5625e7158a7c606620842395e991dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a list of X509 certificates.  <a href="group__cryptolist.html#gaa5625e7158a7c606620842395e991dd5">More...</a><br /></td></tr>
<tr class="separator:gaa5625e7158a7c606620842395e991dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac962c11e1f5c377581a78b8a24a135a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gac962c11e1f5c377581a78b8a24a135a9">GDX509List_num</a> (const struct GDX509List *certs)</td></tr>
<tr class="memdesc:gac962c11e1f5c377581a78b8a24a135a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of X509 certificates.  <a href="group__cryptolist.html#gac962c11e1f5c377581a78b8a24a135a9">More...</a><br /></td></tr>
<tr class="separator:gac962c11e1f5c377581a78b8a24a135a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa154c775230df5c19cdf5ff46c12f5df"><td class="memItemLeft" align="right" valign="top">const struct GDX509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa154c775230df5c19cdf5ff46c12f5df">GDX509List_value</a> (const struct GDX509List *certs, int index)</td></tr>
<tr class="memdesc:gaa154c775230df5c19cdf5ff46c12f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an X509 certificate from a list.  <a href="group__cryptolist.html#gaa154c775230df5c19cdf5ff46c12f5df">More...</a><br /></td></tr>
<tr class="separator:gaa154c775230df5c19cdf5ff46c12f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea5c06ff6d86b85fbed877488bae482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4ea5c06ff6d86b85fbed877488bae482">GDX509List_insert</a> (const struct GDX509List *certs, int index, const struct GDX509 *cert)</td></tr>
<tr class="memdesc:ga4ea5c06ff6d86b85fbed877488bae482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a certificate into the list.  <a href="group__cryptolist.html#ga4ea5c06ff6d86b85fbed877488bae482">More...</a><br /></td></tr>
<tr class="separator:ga4ea5c06ff6d86b85fbed877488bae482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425c53964c61d443256ffdf2cd774f4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga425c53964c61d443256ffdf2cd774f4f">GDX509List_evaluate</a> (const struct GDX509List *certs, const struct GDX509List *not_used, const char *hostname, char **reason)</td></tr>
<tr class="memdesc:ga425c53964c61d443256ffdf2cd774f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a certificate chain.  <a href="group__cryptolist.html#ga425c53964c61d443256ffdf2cd774f4f">More...</a><br /></td></tr>
<tr class="separator:ga425c53964c61d443256ffdf2cd774f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d36d0a39dcef094377330d2a09f7fb"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae5d36d0a39dcef094377330d2a09f7fb">GDX509List_trusted_authorities</a> (void)</td></tr>
<tr class="memdesc:gae5d36d0a39dcef094377330d2a09f7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a list of trusted X509 certificate authorities.  <a href="group__cryptolist.html#gae5d36d0a39dcef094377330d2a09f7fb">More...</a><br /></td></tr>
<tr class="separator:gae5d36d0a39dcef094377330d2a09f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21fb824924dcedb2f5211fe1189d656"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa21fb824924dcedb2f5211fe1189d656">GDX509List_all_user_certs</a> (void)</td></tr>
<tr class="memdesc:gaa21fb824924dcedb2f5211fe1189d656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all user certificates managed by Dynamics.  <a href="group__cryptolist.html#gaa21fb824924dcedb2f5211fe1189d656">More...</a><br /></td></tr>
<tr class="separator:gaa21fb824924dcedb2f5211fe1189d656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a219d6cfb7ebb865a3fca0b7d78ff2e"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1a219d6cfb7ebb865a3fca0b7d78ff2e">GDX509List_valid_user_signing_certs</a> (void)</td></tr>
<tr class="memdesc:ga1a219d6cfb7ebb865a3fca0b7d78ff2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all valid user certificates managed by Dynamics.  <a href="group__cryptolist.html#ga1a219d6cfb7ebb865a3fca0b7d78ff2e">More...</a><br /></td></tr>
<tr class="separator:ga1a219d6cfb7ebb865a3fca0b7d78ff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb65bee2c652d2f18317cfddf08cd5c"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7bb65bee2c652d2f18317cfddf08cd5c">GDX509List_valid_user_encryption_certs</a> (void)</td></tr>
<tr class="memdesc:ga7bb65bee2c652d2f18317cfddf08cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all valid user encryption certificates managed by Dynamics.  <a href="group__cryptolist.html#ga7bb65bee2c652d2f18317cfddf08cd5c">More...</a><br /></td></tr>
<tr class="separator:ga7bb65bee2c652d2f18317cfddf08cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80764272a700a06e273741aba77a8fea"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga80764272a700a06e273741aba77a8fea">GDX509List_all_user_encryption_certs</a> (void)</td></tr>
<tr class="memdesc:ga80764272a700a06e273741aba77a8fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all user encryption certificates managed by Dynamics.  <a href="group__cryptolist.html#ga80764272a700a06e273741aba77a8fea">More...</a><br /></td></tr>
<tr class="separator:ga80764272a700a06e273741aba77a8fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd651b0cd95117c99b7c423afa4e3354"><td class="memItemLeft" align="right" valign="top">struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gabd651b0cd95117c99b7c423afa4e3354">GDX509List_aux_certs</a> (const struct GDX509 *cert)</td></tr>
<tr class="memdesc:gabd651b0cd95117c99b7c423afa4e3354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a certificate chain for a user certificate.  <a href="group__cryptolist.html#gabd651b0cd95117c99b7c423afa4e3354">More...</a><br /></td></tr>
<tr class="separator:gabd651b0cd95117c99b7c423afa4e3354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ddd08f6b1c371c3e784dfa2f90f613"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga92ddd08f6b1c371c3e784dfa2f90f613">GDX509List_free</a> (struct GDX509List *certs)</td></tr>
<tr class="memdesc:ga92ddd08f6b1c371c3e784dfa2f90f613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a X509 list structure.  <a href="group__cryptolist.html#ga92ddd08f6b1c371c3e784dfa2f90f613">More...</a><br /></td></tr>
<tr class="separator:ga92ddd08f6b1c371c3e784dfa2f90f613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4d11701b4eacbba17999067925a4d3"><td class="memItemLeft" align="right" valign="top">struct GDKey *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gacf4d11701b4eacbba17999067925a4d3">GDKey_public</a> (const struct GDX509 *cert)</td></tr>
<tr class="memdesc:gacf4d11701b4eacbba17999067925a4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the public key.  <a href="group__cryptolist.html#gacf4d11701b4eacbba17999067925a4d3">More...</a><br /></td></tr>
<tr class="separator:gacf4d11701b4eacbba17999067925a4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdecd54690f6a55a024bb049dc2626d1"><td class="memItemLeft" align="right" valign="top">struct GDKey *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gabdecd54690f6a55a024bb049dc2626d1">GDKey_private</a> (const struct GDX509 *cert)</td></tr>
<tr class="memdesc:gabdecd54690f6a55a024bb049dc2626d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an opaque private key corresponding to a user certificate.  <a href="group__cryptolist.html#gabdecd54690f6a55a024bb049dc2626d1">More...</a><br /></td></tr>
<tr class="separator:gabdecd54690f6a55a024bb049dc2626d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b4cc18f8a0358eca02db69213060195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4b4cc18f8a0358eca02db69213060195">GDKey_free</a> (struct GDKey *key)</td></tr>
<tr class="memdesc:ga4b4cc18f8a0358eca02db69213060195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a key structure.  <a href="group__cryptolist.html#ga4b4cc18f8a0358eca02db69213060195">More...</a><br /></td></tr>
<tr class="separator:ga4b4cc18f8a0358eca02db69213060195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3faa39d13b07e6741d4913eb726d3465"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga3faa39d13b07e6741d4913eb726d3465">GDKey_compare</a> (const struct GDKey *a, const struct GDKey *b)</td></tr>
<tr class="memdesc:ga3faa39d13b07e6741d4913eb726d3465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two keys.  <a href="group__cryptolist.html#ga3faa39d13b07e6741d4913eb726d3465">More...</a><br /></td></tr>
<tr class="separator:ga3faa39d13b07e6741d4913eb726d3465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6e2f58acb9b176f5776e4f0b319992"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga5c6e2f58acb9b176f5776e4f0b319992">GDKey_size</a> (const struct GDKey *key)</td></tr>
<tr class="memdesc:ga5c6e2f58acb9b176f5776e4f0b319992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature size.  <a href="group__cryptolist.html#ga5c6e2f58acb9b176f5776e4f0b319992">More...</a><br /></td></tr>
<tr class="separator:ga5c6e2f58acb9b176f5776e4f0b319992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac065a80e0e78833217a8a6c8abb74c6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gac065a80e0e78833217a8a6c8abb74c6e">GDKey_bits</a> (const struct GDKey *key)</td></tr>
<tr class="memdesc:gac065a80e0e78833217a8a6c8abb74c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key size.  <a href="group__cryptolist.html#gac065a80e0e78833217a8a6c8abb74c6e">More...</a><br /></td></tr>
<tr class="separator:gac065a80e0e78833217a8a6c8abb74c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a85a056ae70f0840723a057181dd0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga41a85a056ae70f0840723a057181dd0a">GDKey_type</a> (const struct GDKey *key)</td></tr>
<tr class="memdesc:ga41a85a056ae70f0840723a057181dd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type.  <a href="group__cryptolist.html#ga41a85a056ae70f0840723a057181dd0a">More...</a><br /></td></tr>
<tr class="separator:ga41a85a056ae70f0840723a057181dd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9b4c61ef8fcfd7c248bde9a352940d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1c9b4c61ef8fcfd7c248bde9a352940d">GDKey_name</a> (const struct GDKey *key)</td></tr>
<tr class="memdesc:ga1c9b4c61ef8fcfd7c248bde9a352940d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the key algorithm name.  <a href="group__cryptolist.html#ga1c9b4c61ef8fcfd7c248bde9a352940d">More...</a><br /></td></tr>
<tr class="separator:ga1c9b4c61ef8fcfd7c248bde9a352940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec8e3da768ae7621d21ddb962fd0275"><td class="memItemLeft" align="right" valign="top">struct GDKeyContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga6ec8e3da768ae7621d21ddb962fd0275">GDKeyContext_new</a> (struct GDKey *key)</td></tr>
<tr class="memdesc:ga6ec8e3da768ae7621d21ddb962fd0275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new key context.  <a href="group__cryptolist.html#ga6ec8e3da768ae7621d21ddb962fd0275">More...</a><br /></td></tr>
<tr class="separator:ga6ec8e3da768ae7621d21ddb962fd0275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242e61bfbcec060da52802330b92e912"><td class="memItemLeft" align="right" valign="top">struct GDKeyContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga242e61bfbcec060da52802330b92e912">GDKeyContext_copy</a> (struct GDKeyContext *ctx)</td></tr>
<tr class="memdesc:ga242e61bfbcec060da52802330b92e912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a key context.  <a href="group__cryptolist.html#ga242e61bfbcec060da52802330b92e912">More...</a><br /></td></tr>
<tr class="separator:ga242e61bfbcec060da52802330b92e912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b12a5cd6d9f88791da0b865a4e0454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa5b12a5cd6d9f88791da0b865a4e0454">GDKeyContext_free</a> (struct GDKeyContext *ctx)</td></tr>
<tr class="memdesc:gaa5b12a5cd6d9f88791da0b865a4e0454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a key context.  <a href="group__cryptolist.html#gaa5b12a5cd6d9f88791da0b865a4e0454">More...</a><br /></td></tr>
<tr class="separator:gaa5b12a5cd6d9f88791da0b865a4e0454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82df88f30fb770da2dc1c10e3a7a34ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga82df88f30fb770da2dc1c10e3a7a34ab">GDKey_sign_init</a> (struct GDKeyContext *ctx)</td></tr>
<tr class="memdesc:ga82df88f30fb770da2dc1c10e3a7a34ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a key context for signing.  <a href="group__cryptolist.html#ga82df88f30fb770da2dc1c10e3a7a34ab">More...</a><br /></td></tr>
<tr class="separator:ga82df88f30fb770da2dc1c10e3a7a34ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6a00ed83e2ea32b869e0fd305021e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4a6a00ed83e2ea32b869e0fd305021e2">GDKey_sign</a> (struct GDKeyContext *ctx, void *signature, size_t *signature_length, const void *message, size_t message_length)</td></tr>
<tr class="memdesc:ga4a6a00ed83e2ea32b869e0fd305021e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a message.  <a href="group__cryptolist.html#ga4a6a00ed83e2ea32b869e0fd305021e2">More...</a><br /></td></tr>
<tr class="separator:ga4a6a00ed83e2ea32b869e0fd305021e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadedb564fbb6cd9c5a0220d1c5b38a288"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gadedb564fbb6cd9c5a0220d1c5b38a288">GDKey_verify_init</a> (struct GDKeyContext *ctx)</td></tr>
<tr class="memdesc:gadedb564fbb6cd9c5a0220d1c5b38a288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a key context for verification.  <a href="group__cryptolist.html#gadedb564fbb6cd9c5a0220d1c5b38a288">More...</a><br /></td></tr>
<tr class="separator:gadedb564fbb6cd9c5a0220d1c5b38a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7f18114b4d81cf3fae2023706cf416"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga8c7f18114b4d81cf3fae2023706cf416">GDKey_verify</a> (struct GDKeyContext *ctx, const void *signature, size_t signature_length, const void *message, size_t message_length)</td></tr>
<tr class="memdesc:ga8c7f18114b4d81cf3fae2023706cf416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signed message.  <a href="group__cryptolist.html#ga8c7f18114b4d81cf3fae2023706cf416">More...</a><br /></td></tr>
<tr class="separator:ga8c7f18114b4d81cf3fae2023706cf416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf311586c241be32565544012d0255cbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaf311586c241be32565544012d0255cbe">GDKey_encrypt_init</a> (struct GDKeyContext *ctx)</td></tr>
<tr class="memdesc:gaf311586c241be32565544012d0255cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a key context for encryption.  <a href="group__cryptolist.html#gaf311586c241be32565544012d0255cbe">More...</a><br /></td></tr>
<tr class="separator:gaf311586c241be32565544012d0255cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b1056fdb80168e2514867a9c03f624"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab4b1056fdb80168e2514867a9c03f624">GDKey_encrypt</a> (struct GDKeyContext *ctx, void *encrypted, size_t *encrypted_length, const void *clear, size_t clear_length)</td></tr>
<tr class="memdesc:gab4b1056fdb80168e2514867a9c03f624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data.  <a href="group__cryptolist.html#gab4b1056fdb80168e2514867a9c03f624">More...</a><br /></td></tr>
<tr class="separator:gab4b1056fdb80168e2514867a9c03f624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0c995685fa179294a6db48c5d6a55e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gafb0c995685fa179294a6db48c5d6a55e">GDKey_decrypt_init</a> (struct GDKeyContext *ctx)</td></tr>
<tr class="memdesc:gafb0c995685fa179294a6db48c5d6a55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a key context for decryption.  <a href="group__cryptolist.html#gafb0c995685fa179294a6db48c5d6a55e">More...</a><br /></td></tr>
<tr class="separator:gafb0c995685fa179294a6db48c5d6a55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7afd23d01738d6078485997452d8312"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaf7afd23d01738d6078485997452d8312">GDKey_decrypt</a> (struct GDKeyContext *ctx, void *clear, size_t *clear_length, const void *encrypted, size_t encrypted_length)</td></tr>
<tr class="memdesc:gaf7afd23d01738d6078485997452d8312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data.  <a href="group__cryptolist.html#gaf7afd23d01738d6078485997452d8312">More...</a><br /></td></tr>
<tr class="separator:gaf7afd23d01738d6078485997452d8312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a65c0a8c43b2537cc976c287f4a23c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga50a65c0a8c43b2537cc976c287f4a23c">GDKey_sign_final</a> (struct GDDigestContext *digest, void *signature, unsigned int *signature_length, struct GDKey *key)</td></tr>
<tr class="memdesc:ga50a65c0a8c43b2537cc976c287f4a23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a digest.  <a href="group__cryptolist.html#ga50a65c0a8c43b2537cc976c287f4a23c">More...</a><br /></td></tr>
<tr class="separator:ga50a65c0a8c43b2537cc976c287f4a23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125066dbdb13f1e2c2c766c04b537b04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga125066dbdb13f1e2c2c766c04b537b04">GDKey_verify_final</a> (struct GDDigestContext *digest, const void *signature, unsigned int signature_length, struct GDKey *key)</td></tr>
<tr class="memdesc:ga125066dbdb13f1e2c2c766c04b537b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a digest.  <a href="group__cryptolist.html#ga125066dbdb13f1e2c2c766c04b537b04">More...</a><br /></td></tr>
<tr class="separator:ga125066dbdb13f1e2c2c766c04b537b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cb9f1eac95e253060d3a82396566ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga16cb9f1eac95e253060d3a82396566ca">GDKey_set_signature_md</a> (struct GDKeyContext *ctx, const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest)</td></tr>
<tr class="memdesc:ga16cb9f1eac95e253060d3a82396566ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message digest type used in a signature.  <a href="group__cryptolist.html#ga16cb9f1eac95e253060d3a82396566ca">More...</a><br /></td></tr>
<tr class="separator:ga16cb9f1eac95e253060d3a82396566ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf195d55d54f92da1f0a91fe9d4da2593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaf195d55d54f92da1f0a91fe9d4da2593">GDKey_get_signature_md</a> (struct GDKeyContext *ctx, const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> **digest)</td></tr>
<tr class="memdesc:gaf195d55d54f92da1f0a91fe9d4da2593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message digest type.  <a href="group__cryptolist.html#gaf195d55d54f92da1f0a91fe9d4da2593">More...</a><br /></td></tr>
<tr class="separator:gaf195d55d54f92da1f0a91fe9d4da2593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8d2fccf52a833bf03d9f18b14f5ad6"><td class="memItemLeft" align="right" valign="top">struct GDPKCS7 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gafd8d2fccf52a833bf03d9f18b14f5ad6">GDPKCS7_SMIME_read</a> (struct GDStream *stream, struct GDStream **clearText, int flags)</td></tr>
<tr class="memdesc:gafd8d2fccf52a833bf03d9f18b14f5ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize SMIME to a PKCS7 structure.  <a href="group__cryptolist.html#gafd8d2fccf52a833bf03d9f18b14f5ad6">More...</a><br /></td></tr>
<tr class="separator:gafd8d2fccf52a833bf03d9f18b14f5ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4512a991eb135ffed09ee7f815062b50"><td class="memItemLeft" align="right" valign="top">struct GDPKCS7 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4512a991eb135ffed09ee7f815062b50">GDPKCS7_read</a> (struct GDStream *stream, int flags)</td></tr>
<tr class="memdesc:ga4512a991eb135ffed09ee7f815062b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize ASN.1/DER encoding to a PKCS7 structure.  <a href="group__cryptolist.html#ga4512a991eb135ffed09ee7f815062b50">More...</a><br /></td></tr>
<tr class="separator:ga4512a991eb135ffed09ee7f815062b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7860d200df33e48af0064bd5bad459bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb">GDPKCS7_type</a> (struct GDPKCS7 *p7, int flags)</td></tr>
<tr class="memdesc:ga7860d200df33e48af0064bd5bad459bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the type of PKCS7 structure.  <a href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb">More...</a><br /></td></tr>
<tr class="separator:ga7860d200df33e48af0064bd5bad459bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa486dacc671585715da0b3fba02e5789"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa486dacc671585715da0b3fba02e5789">GDPKCS7_verify</a> (struct GDPKCS7 *p7, const struct GDX509List *certs, const struct GDX509List *anchors, struct GDStream *indata, struct GDStream *out, int flags)</td></tr>
<tr class="memdesc:gaa486dacc671585715da0b3fba02e5789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a PKCS7 signedData structure.  <a href="group__cryptolist.html#gaa486dacc671585715da0b3fba02e5789">More...</a><br /></td></tr>
<tr class="separator:gaa486dacc671585715da0b3fba02e5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2d883fc7f056a87fdd07eb45115d23"><td class="memItemLeft" align="right" valign="top">const struct GDX509List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7f2d883fc7f056a87fdd07eb45115d23">GDPKCS7_get_signers</a> (struct GDPKCS7 *p7, int flags)</td></tr>
<tr class="memdesc:ga7f2d883fc7f056a87fdd07eb45115d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the signer's certificate(s).  <a href="group__cryptolist.html#ga7f2d883fc7f056a87fdd07eb45115d23">More...</a><br /></td></tr>
<tr class="separator:ga7f2d883fc7f056a87fdd07eb45115d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9255f52b83769c2047d0c07148df2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gace9255f52b83769c2047d0c07148df2a">GDPKCS7_decrypt</a> (struct GDPKCS7 *p7, struct GDKey *pkey, const struct GDX509 *cert, struct GDStream *data, int flags)</td></tr>
<tr class="memdesc:gace9255f52b83769c2047d0c07148df2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a PKCS7 envelopedData structure.  <a href="group__cryptolist.html#gace9255f52b83769c2047d0c07148df2a">More...</a><br /></td></tr>
<tr class="separator:gace9255f52b83769c2047d0c07148df2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1671a701935fd5d7ed1856ace0c2e42f"><td class="memItemLeft" align="right" valign="top">struct GDPKCS7 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1671a701935fd5d7ed1856ace0c2e42f">GDPKCS7_encrypt</a> (struct GDX509List *certs, struct GDStream *in, const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *cipher, int flags)</td></tr>
<tr class="memdesc:ga1671a701935fd5d7ed1856ace0c2e42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PKCS7 envelopedData structure.  <a href="group__cryptolist.html#ga1671a701935fd5d7ed1856ace0c2e42f">More...</a><br /></td></tr>
<tr class="separator:ga1671a701935fd5d7ed1856ace0c2e42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa146b39ea5ed4d514cfb9f77423f21"><td class="memItemLeft" align="right" valign="top">struct GDPKCS7 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaafa146b39ea5ed4d514cfb9f77423f21">GDPKCS7_add_signer</a> (const struct GDX509 *signcert, struct GDKey *pkey, struct GDX509List *certs, const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *md, int flags)</td></tr>
<tr class="memdesc:gaafa146b39ea5ed4d514cfb9f77423f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add signer information to a PKCS7 structure.  <a href="group__cryptolist.html#gaafa146b39ea5ed4d514cfb9f77423f21">More...</a><br /></td></tr>
<tr class="separator:gaafa146b39ea5ed4d514cfb9f77423f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204e54a49c04910f06a649ddd4c77903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga204e54a49c04910f06a649ddd4c77903">GDPKCS7_final</a> (struct GDPKCS7 *p7, struct GDStream *data, int flags)</td></tr>
<tr class="memdesc:ga204e54a49c04910f06a649ddd4c77903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a PKCS7 structure.  <a href="group__cryptolist.html#ga204e54a49c04910f06a649ddd4c77903">More...</a><br /></td></tr>
<tr class="separator:ga204e54a49c04910f06a649ddd4c77903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56847d709eb1de5d0cffd07cca231ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad56847d709eb1de5d0cffd07cca231ef">GDPKCS7_write</a> (struct GDStream *stream, struct GDPKCS7 *p7, int flags)</td></tr>
<tr class="memdesc:gad56847d709eb1de5d0cffd07cca231ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a PKCS7 structure to ASN.1/DER encoding.  <a href="group__cryptolist.html#gad56847d709eb1de5d0cffd07cca231ef">More...</a><br /></td></tr>
<tr class="separator:gad56847d709eb1de5d0cffd07cca231ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239be66e49caea7a77a495d5b3410903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga239be66e49caea7a77a495d5b3410903">GDPKCS7_SMIME_write</a> (struct GDStream *stream, struct GDPKCS7 *p7, struct GDStream *data, int flags)</td></tr>
<tr class="memdesc:ga239be66e49caea7a77a495d5b3410903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a PKCS7 structure to SMIME encoding.  <a href="group__cryptolist.html#ga239be66e49caea7a77a495d5b3410903">More...</a><br /></td></tr>
<tr class="separator:ga239be66e49caea7a77a495d5b3410903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc30ba55ac0922ffc4a45aeb0060ed81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gabc30ba55ac0922ffc4a45aeb0060ed81">GDPKCS7_free</a> (struct GDPKCS7 *p7, int flags)</td></tr>
<tr class="memdesc:gabc30ba55ac0922ffc4a45aeb0060ed81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a PKCS7 structure.  <a href="group__cryptolist.html#gabc30ba55ac0922ffc4a45aeb0060ed81">More...</a><br /></td></tr>
<tr class="separator:gabc30ba55ac0922ffc4a45aeb0060ed81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3468e3058119ca607c938cd7c374aacf"><td class="memItemLeft" align="right" valign="top">struct GDRSA *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga3468e3058119ca607c938cd7c374aacf">GDRSA_public_key</a> (const struct GDX509 *cert)</td></tr>
<tr class="memdesc:ga3468e3058119ca607c938cd7c374aacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the RSA public key.  <a href="group__cryptolist.html#ga3468e3058119ca607c938cd7c374aacf">More...</a><br /></td></tr>
<tr class="separator:ga3468e3058119ca607c938cd7c374aacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a317239a17c7a77c0988b7e8f9447ff"><td class="memItemLeft" align="right" valign="top">struct GDRSA *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga7a317239a17c7a77c0988b7e8f9447ff">GDRSA_private_key</a> (const struct GDX509 *cert)</td></tr>
<tr class="memdesc:ga7a317239a17c7a77c0988b7e8f9447ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pseudo private RSA key corresponding to a user certificate.  <a href="group__cryptolist.html#ga7a317239a17c7a77c0988b7e8f9447ff">More...</a><br /></td></tr>
<tr class="separator:ga7a317239a17c7a77c0988b7e8f9447ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185500055c023cbbfd1a6b6bcc2c79fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb">GDRSA_size</a> (const struct GDRSA *rsa)</td></tr>
<tr class="memdesc:ga185500055c023cbbfd1a6b6bcc2c79fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA modulus size.  <a href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb">More...</a><br /></td></tr>
<tr class="separator:ga185500055c023cbbfd1a6b6bcc2c79fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc58fcd95c10cc41d6debcec23c1699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga8fc58fcd95c10cc41d6debcec23c1699">GDRSA_free</a> (struct GDRSA *rsa)</td></tr>
<tr class="memdesc:ga8fc58fcd95c10cc41d6debcec23c1699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a RSA key structure.  <a href="group__cryptolist.html#ga8fc58fcd95c10cc41d6debcec23c1699">More...</a><br /></td></tr>
<tr class="separator:ga8fc58fcd95c10cc41d6debcec23c1699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3460a3dc46351804c5d49f25f34869"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaef3460a3dc46351804c5d49f25f34869">GDRSA_sign</a> (const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest_algorithm, const void *digest, unsigned int digest_size, void *signature, unsigned int *signature_size, struct GDRSA *rsa)</td></tr>
<tr class="memdesc:gaef3460a3dc46351804c5d49f25f34869"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA sign a message digest.  <a href="group__cryptolist.html#gaef3460a3dc46351804c5d49f25f34869">More...</a><br /></td></tr>
<tr class="separator:gaef3460a3dc46351804c5d49f25f34869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bcb4c48e92e48b0a5be9db0645ed8bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga3bcb4c48e92e48b0a5be9db0645ed8bc">GDRSA_verify</a> (const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *digest_algorithm, const void *digest, unsigned int digest_size, const void *signature, unsigned int signature_size, struct GDRSA *rsa)</td></tr>
<tr class="memdesc:ga3bcb4c48e92e48b0a5be9db0645ed8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an RSA signed message.  <a href="group__cryptolist.html#ga3bcb4c48e92e48b0a5be9db0645ed8bc">More...</a><br /></td></tr>
<tr class="separator:ga3bcb4c48e92e48b0a5be9db0645ed8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72cadd9241a305d81ff3e34987d54617"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga72cadd9241a305d81ff3e34987d54617">GDRSA_public_encrypt</a> (int flen, const void *from, void *to, struct GDRSA *rsa, int padding)</td></tr>
<tr class="memdesc:ga72cadd9241a305d81ff3e34987d54617"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA public encrypt.  <a href="group__cryptolist.html#ga72cadd9241a305d81ff3e34987d54617">More...</a><br /></td></tr>
<tr class="separator:ga72cadd9241a305d81ff3e34987d54617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c2b407f98e494dfdfb4064a84eb092"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga70c2b407f98e494dfdfb4064a84eb092">GDRSA_private_decrypt</a> (int flen, const void *from, void *to, struct GDRSA *rsa, int padding)</td></tr>
<tr class="memdesc:ga70c2b407f98e494dfdfb4064a84eb092"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA private decrypt.  <a href="group__cryptolist.html#ga70c2b407f98e494dfdfb4064a84eb092">More...</a><br /></td></tr>
<tr class="separator:ga70c2b407f98e494dfdfb4064a84eb092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98ba7cdc1f55471ba9821f5c45ceb19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae98ba7cdc1f55471ba9821f5c45ceb19">GDRSA_private_encrypt</a> (int flen, const void *from, void *to, struct GDRSA *rsa, int padding)</td></tr>
<tr class="memdesc:gae98ba7cdc1f55471ba9821f5c45ceb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA private encrypt.  <a href="group__cryptolist.html#gae98ba7cdc1f55471ba9821f5c45ceb19">More...</a><br /></td></tr>
<tr class="separator:gae98ba7cdc1f55471ba9821f5c45ceb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9725e3df743e44b9be0ca896613b5acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga9725e3df743e44b9be0ca896613b5acf">GDRSA_public_decrypt</a> (int flen, const void *from, void *to, struct GDRSA *rsa, int padding)</td></tr>
<tr class="memdesc:ga9725e3df743e44b9be0ca896613b5acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA public decrypt.  <a href="group__cryptolist.html#ga9725e3df743e44b9be0ca896613b5acf">More...</a><br /></td></tr>
<tr class="separator:ga9725e3df743e44b9be0ca896613b5acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920a5b7c249b272d0b8eb595368c67fb"><td class="memItemLeft" align="right" valign="top">const struct GDStreamStorageMethod *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga920a5b7c249b272d0b8eb595368c67fb">GDStream_mem_storage_method</a> (void)</td></tr>
<tr class="memdesc:ga920a5b7c249b272d0b8eb595368c67fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a memory stream storage method.  <a href="group__cryptolist.html#ga920a5b7c249b272d0b8eb595368c67fb">More...</a><br /></td></tr>
<tr class="separator:ga920a5b7c249b272d0b8eb595368c67fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2df7cc9b9b124eb4fc68206269ab8d"><td class="memItemLeft" align="right" valign="top">struct GDStream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaae2df7cc9b9b124eb4fc68206269ab8d">GDStream_new_mem_buf</a> (const void *buf, int len)</td></tr>
<tr class="memdesc:gaae2df7cc9b9b124eb4fc68206269ab8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream from a region of memory.  <a href="group__cryptolist.html#gaae2df7cc9b9b124eb4fc68206269ab8d">More...</a><br /></td></tr>
<tr class="separator:gaae2df7cc9b9b124eb4fc68206269ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab94a772f1cb4d7e4a53c02748f98e76b"><td class="memItemLeft" align="right" valign="top">struct GDStream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab94a772f1cb4d7e4a53c02748f98e76b">GDStream_new</a> (const struct GDStreamStorageMethod *method)</td></tr>
<tr class="memdesc:gab94a772f1cb4d7e4a53c02748f98e76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream.  <a href="group__cryptolist.html#gab94a772f1cb4d7e4a53c02748f98e76b">More...</a><br /></td></tr>
<tr class="separator:gab94a772f1cb4d7e4a53c02748f98e76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1caa3ceda70cbf98a26e4cc5bc61838e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1caa3ceda70cbf98a26e4cc5bc61838e">GDStream_read</a> (struct GDStream *stream, void *data, int len)</td></tr>
<tr class="memdesc:ga1caa3ceda70cbf98a26e4cc5bc61838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a stream.  <a href="group__cryptolist.html#ga1caa3ceda70cbf98a26e4cc5bc61838e">More...</a><br /></td></tr>
<tr class="separator:ga1caa3ceda70cbf98a26e4cc5bc61838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054f6b119ffe8f96223813029e1be535"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga054f6b119ffe8f96223813029e1be535">GDStream_write</a> (struct GDStream *stream, const void *data, int len)</td></tr>
<tr class="memdesc:ga054f6b119ffe8f96223813029e1be535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a stream.  <a href="group__cryptolist.html#ga054f6b119ffe8f96223813029e1be535">More...</a><br /></td></tr>
<tr class="separator:ga054f6b119ffe8f96223813029e1be535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2ee36c79c2c80ab0d4fb813e37b364"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga9e2ee36c79c2c80ab0d4fb813e37b364">GDStream_reset</a> (struct GDStream *stream)</td></tr>
<tr class="memdesc:ga9e2ee36c79c2c80ab0d4fb813e37b364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a stream.  <a href="group__cryptolist.html#ga9e2ee36c79c2c80ab0d4fb813e37b364">More...</a><br /></td></tr>
<tr class="separator:ga9e2ee36c79c2c80ab0d4fb813e37b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575f45860956e3766fdec7b794e4a0b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga575f45860956e3766fdec7b794e4a0b1">GDStream_eof</a> (struct GDStream *stream)</td></tr>
<tr class="memdesc:ga575f45860956e3766fdec7b794e4a0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if stream has reached the end.  <a href="group__cryptolist.html#ga575f45860956e3766fdec7b794e4a0b1">More...</a><br /></td></tr>
<tr class="separator:ga575f45860956e3766fdec7b794e4a0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67666c659f796f09bc71f3401a29629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae67666c659f796f09bc71f3401a29629">GDStream_free</a> (struct GDStream *stream)</td></tr>
<tr class="memdesc:gae67666c659f796f09bc71f3401a29629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a stream structure.  <a href="group__cryptolist.html#gae67666c659f796f09bc71f3401a29629">More...</a><br /></td></tr>
<tr class="separator:gae67666c659f796f09bc71f3401a29629"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga305361f4befc0497771546d3d4d30935"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga305361f4befc0497771546d3d4d30935">GDCIPHER_MAX_BLOCK_LENGTH</a></td></tr>
<tr class="memdesc:ga305361f4befc0497771546d3d4d30935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum block length for all ciphers.  <a href="group__cryptolist.html#ga305361f4befc0497771546d3d4d30935">More...</a><br /></td></tr>
<tr class="separator:ga305361f4befc0497771546d3d4d30935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373d4650baaa116ee46cf93b9f30c572"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga373d4650baaa116ee46cf93b9f30c572">GDCIPHER_MAX_KEY_LENGTH</a></td></tr>
<tr class="memdesc:ga373d4650baaa116ee46cf93b9f30c572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum key length for all ciphers.  <a href="group__cryptolist.html#ga373d4650baaa116ee46cf93b9f30c572">More...</a><br /></td></tr>
<tr class="separator:ga373d4650baaa116ee46cf93b9f30c572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ee68af9f04f1bcd6caf8e2578bf347"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga38ee68af9f04f1bcd6caf8e2578bf347">GDCIPHER_STREAM_CIPHER</a></td></tr>
<tr class="memdesc:ga38ee68af9f04f1bcd6caf8e2578bf347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream cipher mode.  <a href="group__cryptolist.html#ga38ee68af9f04f1bcd6caf8e2578bf347">More...</a><br /></td></tr>
<tr class="separator:ga38ee68af9f04f1bcd6caf8e2578bf347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c7e48657fb7601c63822cb7de1caca"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad0c7e48657fb7601c63822cb7de1caca">GDCIPHER_ECB_MODE</a></td></tr>
<tr class="memdesc:gad0c7e48657fb7601c63822cb7de1caca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECB cipher mode.  <a href="group__cryptolist.html#gad0c7e48657fb7601c63822cb7de1caca">More...</a><br /></td></tr>
<tr class="separator:gad0c7e48657fb7601c63822cb7de1caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b58839eef854a2e8064ee4016abfaa"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga10b58839eef854a2e8064ee4016abfaa">GDCIPHER_CBC_MODE</a></td></tr>
<tr class="memdesc:ga10b58839eef854a2e8064ee4016abfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBC cipher mode.  <a href="group__cryptolist.html#ga10b58839eef854a2e8064ee4016abfaa">More...</a><br /></td></tr>
<tr class="separator:ga10b58839eef854a2e8064ee4016abfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470781ac90767dc3759b22a1a8a9bf46"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga470781ac90767dc3759b22a1a8a9bf46">GDCIPHER_CFB_MODE</a></td></tr>
<tr class="memdesc:ga470781ac90767dc3759b22a1a8a9bf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">CFB cipher mode.  <a href="group__cryptolist.html#ga470781ac90767dc3759b22a1a8a9bf46">More...</a><br /></td></tr>
<tr class="separator:ga470781ac90767dc3759b22a1a8a9bf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9c2c45f513e4dd57a82b8e7ed16e05"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga6a9c2c45f513e4dd57a82b8e7ed16e05">GDCIPHER_OFB_MODE</a></td></tr>
<tr class="memdesc:ga6a9c2c45f513e4dd57a82b8e7ed16e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">OFB cipher mode.  <a href="group__cryptolist.html#ga6a9c2c45f513e4dd57a82b8e7ed16e05">More...</a><br /></td></tr>
<tr class="separator:ga6a9c2c45f513e4dd57a82b8e7ed16e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39f4142d3fdf7c642a86c647cd1d800"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad39f4142d3fdf7c642a86c647cd1d800">GDCIPHER_CTR_MODE</a></td></tr>
<tr class="memdesc:gad39f4142d3fdf7c642a86c647cd1d800"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTR cipher mode.  <a href="group__cryptolist.html#gad39f4142d3fdf7c642a86c647cd1d800">More...</a><br /></td></tr>
<tr class="separator:gad39f4142d3fdf7c642a86c647cd1d800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d0c5fb968590d2a6231f7967cc67df"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaa5d0c5fb968590d2a6231f7967cc67df">GDCIPHER_GCM_MODE</a></td></tr>
<tr class="memdesc:gaa5d0c5fb968590d2a6231f7967cc67df"><td class="mdescLeft">&#160;</td><td class="mdescRight">GCM cipher mode.  <a href="group__cryptolist.html#gaa5d0c5fb968590d2a6231f7967cc67df">More...</a><br /></td></tr>
<tr class="separator:gaa5d0c5fb968590d2a6231f7967cc67df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba33e186f35166aee6be2c7469aa79a"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga9ba33e186f35166aee6be2c7469aa79a">GDCIPHER_CCM_MODE</a></td></tr>
<tr class="memdesc:ga9ba33e186f35166aee6be2c7469aa79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCM cipher mode.  <a href="group__cryptolist.html#ga9ba33e186f35166aee6be2c7469aa79a">More...</a><br /></td></tr>
<tr class="separator:ga9ba33e186f35166aee6be2c7469aa79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42397bfc2d70e622714097ced8e089a"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab42397bfc2d70e622714097ced8e089a">GDCIPHER_XTS_MODE</a></td></tr>
<tr class="memdesc:gab42397bfc2d70e622714097ced8e089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">XTS cipher mode.  <a href="group__cryptolist.html#gab42397bfc2d70e622714097ced8e089a">More...</a><br /></td></tr>
<tr class="separator:gab42397bfc2d70e622714097ced8e089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0febb111ba8f63676b7ad7a154479b2"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae0febb111ba8f63676b7ad7a154479b2">GDCIPHER_WRAP_MODE</a></td></tr>
<tr class="memdesc:gae0febb111ba8f63676b7ad7a154479b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap cipher mode.  <a href="group__cryptolist.html#gae0febb111ba8f63676b7ad7a154479b2">More...</a><br /></td></tr>
<tr class="separator:gae0febb111ba8f63676b7ad7a154479b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6428e5873337845316936f7f7e727aac"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga6428e5873337845316936f7f7e727aac">GDDIGEST_MAX_SIZE</a></td></tr>
<tr class="memdesc:ga6428e5873337845316936f7f7e727aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum supported digest size in bytes.  <a href="group__cryptolist.html#ga6428e5873337845316936f7f7e727aac">More...</a><br /></td></tr>
<tr class="separator:ga6428e5873337845316936f7f7e727aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c882911bee25ae0d032f631285e2a03"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga6c882911bee25ae0d032f631285e2a03">GDKEY_TYPE_RSA</a></td></tr>
<tr class="memdesc:ga6c882911bee25ae0d032f631285e2a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA key type.  <a href="group__cryptolist.html#ga6c882911bee25ae0d032f631285e2a03">More...</a><br /></td></tr>
<tr class="separator:ga6c882911bee25ae0d032f631285e2a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b999875e8f6a2f8b5fd7406b4233b2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga59b999875e8f6a2f8b5fd7406b4233b2">GDKEY_TYPE_DSA</a></td></tr>
<tr class="memdesc:ga59b999875e8f6a2f8b5fd7406b4233b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSA key type.  <a href="group__cryptolist.html#ga59b999875e8f6a2f8b5fd7406b4233b2">More...</a><br /></td></tr>
<tr class="separator:ga59b999875e8f6a2f8b5fd7406b4233b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab70c40120b2cf96be15708e789e3c668"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gab70c40120b2cf96be15708e789e3c668">GDKEY_TYPE_EC</a></td></tr>
<tr class="memdesc:gab70c40120b2cf96be15708e789e3c668"><td class="mdescLeft">&#160;</td><td class="mdescRight">EC key type.  <a href="group__cryptolist.html#gab70c40120b2cf96be15708e789e3c668">More...</a><br /></td></tr>
<tr class="separator:gab70c40120b2cf96be15708e789e3c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86422d42e837f073526b0bed30c4fe9d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga86422d42e837f073526b0bed30c4fe9d">GDPKCS7_TEXT</a></td></tr>
<tr class="memdesc:ga86422d42e837f073526b0bed30c4fe9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 flags.  <a href="group__cryptolist.html#ga86422d42e837f073526b0bed30c4fe9d">More...</a><br /></td></tr>
<tr class="separator:ga86422d42e837f073526b0bed30c4fe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc258a771553b6fbb207a219b21ee85e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gafc258a771553b6fbb207a219b21ee85e">GDPKCS7_NOCERTS</a></td></tr>
<tr class="separator:gafc258a771553b6fbb207a219b21ee85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf88d5ae48abe9425c218dea063eec6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga4bf88d5ae48abe9425c218dea063eec6">GDPKCS7_NOSIGS</a></td></tr>
<tr class="separator:ga4bf88d5ae48abe9425c218dea063eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac343f9cc25111fd2d4f53f9dc5f21331"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gac343f9cc25111fd2d4f53f9dc5f21331">GDPKCS7_NOCHAIN</a></td></tr>
<tr class="separator:gac343f9cc25111fd2d4f53f9dc5f21331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5172cd7fb1b3755868dd182e795bd746"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga5172cd7fb1b3755868dd182e795bd746">GDPKCS7_NOINTERN</a></td></tr>
<tr class="separator:ga5172cd7fb1b3755868dd182e795bd746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e65e23a8d71ebb0db48677308c49293"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga8e65e23a8d71ebb0db48677308c49293">GDPKCS7_NOVERIFY</a></td></tr>
<tr class="separator:ga8e65e23a8d71ebb0db48677308c49293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69cd0eeee17335f4f89c2fa29cce6186"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga69cd0eeee17335f4f89c2fa29cce6186">GDPKCS7_DETACHED</a></td></tr>
<tr class="separator:ga69cd0eeee17335f4f89c2fa29cce6186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34c38e5e513700224d5ef0b92cdfc37"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad34c38e5e513700224d5ef0b92cdfc37">GDPKCS7_BINARY</a></td></tr>
<tr class="separator:gad34c38e5e513700224d5ef0b92cdfc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c52d594e9f3ddeb737fc4b99d1fa3d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga44c52d594e9f3ddeb737fc4b99d1fa3d">GDPKCS7_NOATTR</a></td></tr>
<tr class="separator:ga44c52d594e9f3ddeb737fc4b99d1fa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67941f4ac6ee59ab4938c78d81cf720"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad67941f4ac6ee59ab4938c78d81cf720">GDPKCS7_NOSMIMECAP</a></td></tr>
<tr class="separator:gad67941f4ac6ee59ab4938c78d81cf720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bba5519092e74e59de67c9c875d149a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga6bba5519092e74e59de67c9c875d149a">GDPKCS7_NOOLDMIMETYPE</a></td></tr>
<tr class="separator:ga6bba5519092e74e59de67c9c875d149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d1f809efe7c428dbe6c0145e18c389"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaf1d1f809efe7c428dbe6c0145e18c389">GDPKCS7_CRLFEOL</a></td></tr>
<tr class="separator:gaf1d1f809efe7c428dbe6c0145e18c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ea8a6ad476c832ec03bcf2149068b1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga24ea8a6ad476c832ec03bcf2149068b1">GDPKCS7_STREAM</a></td></tr>
<tr class="separator:ga24ea8a6ad476c832ec03bcf2149068b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c3574621a6ec61e3ce26127bf2e8a3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga79c3574621a6ec61e3ce26127bf2e8a3">GDPKCS7_NOCRL</a></td></tr>
<tr class="separator:ga79c3574621a6ec61e3ce26127bf2e8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d009b78df5f0eb988f1102ba9103e2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga87d009b78df5f0eb988f1102ba9103e2">GDPKCS7_PARTIAL</a></td></tr>
<tr class="separator:ga87d009b78df5f0eb988f1102ba9103e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af3fe8190c9e271c18f68f690445f7d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga1af3fe8190c9e271c18f68f690445f7d">GDPKCS7_REUSE_DIGEST</a></td></tr>
<tr class="separator:ga1af3fe8190c9e271c18f68f690445f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ab616e169eea6a29785e7731e54d59"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gae4ab616e169eea6a29785e7731e54d59">GDPKCS7_USE_KEYID</a></td></tr>
<tr class="separator:gae4ab616e169eea6a29785e7731e54d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d89273bb6291fc17468153a683808b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga42d89273bb6291fc17468153a683808b">GDPKCS7_KEY_PARAM</a></td></tr>
<tr class="separator:ga42d89273bb6291fc17468153a683808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239dbaa148d33cd91242b9cc6abca859"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga239dbaa148d33cd91242b9cc6abca859">GDPKCS7_SIGNED</a></td></tr>
<tr class="memdesc:ga239dbaa148d33cd91242b9cc6abca859"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 content-type:pkcs7-signedData.  <a href="group__cryptolist.html#ga239dbaa148d33cd91242b9cc6abca859">More...</a><br /></td></tr>
<tr class="separator:ga239dbaa148d33cd91242b9cc6abca859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159d697afe2a72fd568e33ab35dcdd32"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga159d697afe2a72fd568e33ab35dcdd32">GDPKCS7_ENCRYPTED</a></td></tr>
<tr class="memdesc:ga159d697afe2a72fd568e33ab35dcdd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 content-type:pkcs7-encryptedData.  <a href="group__cryptolist.html#ga159d697afe2a72fd568e33ab35dcdd32">More...</a><br /></td></tr>
<tr class="separator:ga159d697afe2a72fd568e33ab35dcdd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa13253ed853cca27bccbd01c28ff0a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gabaa13253ed853cca27bccbd01c28ff0a">GDPKCS7_ENVELOPED</a></td></tr>
<tr class="memdesc:gabaa13253ed853cca27bccbd01c28ff0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 content-type:pkcs7-envelopedData.  <a href="group__cryptolist.html#gabaa13253ed853cca27bccbd01c28ff0a">More...</a><br /></td></tr>
<tr class="separator:gabaa13253ed853cca27bccbd01c28ff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ef9c9fb237a0b07d788c348f1b270c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga76ef9c9fb237a0b07d788c348f1b270c">GDPKCS7_SIGNED_AND_ENVELOPED</a></td></tr>
<tr class="memdesc:ga76ef9c9fb237a0b07d788c348f1b270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 content-type:pkcs7-signedAndEnvelopedData.  <a href="group__cryptolist.html#ga76ef9c9fb237a0b07d788c348f1b270c">More...</a><br /></td></tr>
<tr class="separator:ga76ef9c9fb237a0b07d788c348f1b270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f35e619be76051f54efd50a52edc589"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga8f35e619be76051f54efd50a52edc589">GDPKCS7_DATA</a></td></tr>
<tr class="memdesc:ga8f35e619be76051f54efd50a52edc589"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 content-type:pkcs7-data.  <a href="group__cryptolist.html#ga8f35e619be76051f54efd50a52edc589">More...</a><br /></td></tr>
<tr class="separator:ga8f35e619be76051f54efd50a52edc589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2cac241f7aa392f8cc6ba9ef0257a0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gabf2cac241f7aa392f8cc6ba9ef0257a0">GDPKCS7_DIGEST</a></td></tr>
<tr class="memdesc:gabf2cac241f7aa392f8cc6ba9ef0257a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS7 content-type:pkcs7-digestData.  <a href="group__cryptolist.html#gabf2cac241f7aa392f8cc6ba9ef0257a0">More...</a><br /></td></tr>
<tr class="separator:gabf2cac241f7aa392f8cc6ba9ef0257a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cbabf0cfcec812b7d78baffdbd8d7cb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#ga6cbabf0cfcec812b7d78baffdbd8d7cb">GDRSA_PKCS1_PADDING</a></td></tr>
<tr class="memdesc:ga6cbabf0cfcec812b7d78baffdbd8d7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS #1 padding.  <a href="group__cryptolist.html#ga6cbabf0cfcec812b7d78baffdbd8d7cb">More...</a><br /></td></tr>
<tr class="separator:ga6cbabf0cfcec812b7d78baffdbd8d7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31fe9c1ad3e9c599d2173e95792d0ee"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gad31fe9c1ad3e9c599d2173e95792d0ee">GDRSA_PKCS1_OAEP_PADDING</a></td></tr>
<tr class="memdesc:gad31fe9c1ad3e9c599d2173e95792d0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS #1 OAEP padding.  <a href="group__cryptolist.html#gad31fe9c1ad3e9c599d2173e95792d0ee">More...</a><br /></td></tr>
<tr class="separator:gad31fe9c1ad3e9c599d2173e95792d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2e013de4862cd9ec628f54cbb8b84c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cryptolist.html#gaad2e013de4862cd9ec628f54cbb8b84c">GDRSA_NO_PADDING</a></td></tr>
<tr class="memdesc:gaad2e013de4862cd9ec628f54cbb8b84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">No padding.  <a href="group__cryptolist.html#gaad2e013de4862cd9ec628f54cbb8b84c">More...</a><br /></td></tr>
<tr class="separator:gaad2e013de4862cd9ec628f54cbb8b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is a C language programming interface for performing cryptographic operations. The interface enables an app to perform PKCS7 sign, verify, encrypt, decrypt operations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7cc648bc0c2646f957083936fe50b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc648bc0c2646f957083936fe50b572">&#9670;&nbsp;</a></span>GD_C_API_EXT <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GD_C_API_EXT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7cc648bc0c2646f957083936fe50b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc648bc0c2646f957083936fe50b572">&#9670;&nbsp;</a></span>GD_C_API_EXT <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GD_C_API_EXT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7cc648bc0c2646f957083936fe50b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc648bc0c2646f957083936fe50b572">&#9670;&nbsp;</a></span>GD_C_API_EXT <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GD_C_API_EXT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7cc648bc0c2646f957083936fe50b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc648bc0c2646f957083936fe50b572">&#9670;&nbsp;</a></span>GD_C_API_EXT <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GD_C_API_EXT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7cc648bc0c2646f957083936fe50b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc648bc0c2646f957083936fe50b572">&#9670;&nbsp;</a></span>GD_C_API_EXT <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GD_C_API_EXT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7cc648bc0c2646f957083936fe50b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc648bc0c2646f957083936fe50b572">&#9670;&nbsp;</a></span>GD_C_API_EXT <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GD_C_API_EXT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf1f0c793448eb52d749d19da7ab13b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f0c793448eb52d749d19da7ab13b3a">&#9670;&nbsp;</a></span>GDCipher_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char** GDCipher_list </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of supported cipher suite names.</p>
<dl class="section return"><dt>Returns</dt><dd><code>char**</code> an array of c-strings containing the cipher names. </dd></dl>

</div>
</div>
<a id="ga4b321016f22f16f58b65b91bc2a638d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b321016f22f16f58b65b91bc2a638d0">&#9670;&nbsp;</a></span>GDCipher_byname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a>* GDCipher_byname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a cipher structure by suite name. The name must be the long name format as specified in obj_mac.h of OpenSSL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td><code>char*</code> the name of the cipher suite required. For example, "des-ede3-cbc". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDCipher*</code> the cipher suite or NULL. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga86e78a0c799468f822b92b7d6aa33720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86e78a0c799468f822b92b7d6aa33720">&#9670;&nbsp;</a></span>GDCipher_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GDCipher_name </td>
          <td>(</td>
          <td class="paramtype">const struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the given cipher suite. The name will be in long name format as specified in obj_mac.h of OpenSSL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> the cipher context for which the name is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>char*</code> the cipher suite name or NULL. </dd></dl>

</div>
</div>
<a id="gabf7114a8ba37699855bcdfa5537d0253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf7114a8ba37699855bcdfa5537d0253">&#9670;&nbsp;</a></span>GDCipher_bycontext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a>* GDCipher_bycontext </td>
          <td>(</td>
          <td class="paramtype">const struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a cipher structure for the given cipher context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> the context of the cipher required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDCipher*</code> the cipher suite or NULL. </dd></dl>

</div>
</div>
<a id="ga136b15c1b82ead844e8a219c78e6a241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136b15c1b82ead844e8a219c78e6a241">&#9670;&nbsp;</a></span>GDCipher_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td>
          <td class="paramname"><em>cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the block size of a given cipher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td><code>GDCipher*</code> the cipher for which the block size is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the block size of the cipher in bytes. </dd></dl>

</div>
</div>
<a id="ga40ff9d13cb230d81d7734f5bd6c65981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ff9d13cb230d81d7734f5bd6c65981">&#9670;&nbsp;</a></span>GDCipher_key_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_key_length </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td>
          <td class="paramname"><em>cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the key length of a given cipher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td><code>GDCipher*</code> the cipher for which the key length is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the key length of the cipher. </dd></dl>

</div>
</div>
<a id="gab9fd4f95055f8cb9854ffa6212db5f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9fd4f95055f8cb9854ffa6212db5f43">&#9670;&nbsp;</a></span>GDCipher_iv_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_iv_length </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td>
          <td class="paramname"><em>cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the IV length of a given cipher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td><code>GDCipher*</code> the cipher for which the IV length is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the IV length of the cipher. </dd></dl>

</div>
</div>
<a id="ga5e41fcc79af459361b3cf04e64eab9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e41fcc79af459361b3cf04e64eab9a8">&#9670;&nbsp;</a></span>GDCipher_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long GDCipher_mode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td>
          <td class="paramname"><em>cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mode of a given cipher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td><code>GDCipher*</code> the cipher for which the mode is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>unsigned long</code> the mode of the cipher. </dd></dl>

</div>
</div>
<a id="gab4c668c5c417c5cc22bcd299ebe3828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c668c5c417c5cc22bcd299ebe3828e">&#9670;&nbsp;</a></span>GDCipher_set_padding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDCipher_set_padding </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable padding for the given cipher context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> the cipher context for which padding is to be enabled or disabled. </td></tr>
    <tr><td class="paramname">padding</td><td><code>int</code> 0 for no padding, any other value to enable padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga10008504f2c7e42fe0c77724632e0916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10008504f2c7e42fe0c77724632e0916">&#9670;&nbsp;</a></span>GDCipher_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDCipherContext* GDCipher_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cipher context is used to symmetrically encrypt or decrypt a message. The context should be initialized with a specific cipher algorithm by calling <a class="el" href="group__cryptolist.html#gace7bc56282236fdf8b540d775c0eb4c7" title="Initialize a cipher context.">GDCipher_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDCipherContext*</code> a cipher context. </dd></dl>

</div>
</div>
<a id="gace7bc56282236fdf8b540d775c0eb4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace7bc56282236fdf8b540d775c0eb4c7">&#9670;&nbsp;</a></span>GDCipher_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_init </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the cipher context with a specific cipher suite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> a pointer to the cipher context. </td></tr>
    <tr><td class="paramname">cipher</td><td><code>const GDCipher*</code> the cipher suite, for example AES-256-CBC. </td></tr>
    <tr><td class="paramname">key</td><td><code>const void*</code> NULL or the symmetric key to use, depending on the cipher. </td></tr>
    <tr><td class="paramname">iv</td><td><code>const void*</code> NULL or the IV to use, depending on the cipher. </td></tr>
    <tr><td class="paramname">mode</td><td><code>int</code> 1 for encryption, 0 for decryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gab170558ce35f874c1b83fa5824078df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab170558ce35f874c1b83fa5824078df4">&#9670;&nbsp;</a></span>GDCipher_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_copy </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the cipher context. The destination cipher is cleaned up before being updated to match the source cipher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><code>GDCipherContext*</code> a pointer to a cipher context. </td></tr>
    <tr><td class="paramname">destination</td><td><code>const GDCipherContext*</code> the cipher context to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gae50e1927901f05be82921d285422c405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae50e1927901f05be82921d285422c405">&#9670;&nbsp;</a></span>GDCipher_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_update </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_data_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_data_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform encryption or decryption of a message. This function can be called multiple times to encrypt or decrypt successive blocks of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> a pointer to the cipher context. </td></tr>
    <tr><td class="paramname">out_data</td><td><code>void*</code> a buffer large enough to contain the encrypted or decrypted data. The amount of data written may be anything from zero bytes to (in_sz + cipher_block_size - 1). </td></tr>
    <tr><td class="paramname">out_data_sz</td><td><code>size_t</code> the number of bytes written to out_data. </td></tr>
    <tr><td class="paramname">in_data</td><td><code>const void*</code> a pointer to the data to be encrypted or decrypted. </td></tr>
    <tr><td class="paramname">in_data_sz</td><td><code>int</code> the number of bytes of the data to be encrypted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga78b831846627eff0e346332b615a84f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78b831846627eff0e346332b615a84f3">&#9670;&nbsp;</a></span>GDCipher_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_final </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finish encryption or decryption of the last block of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> a pointer to the cipher context. </td></tr>
    <tr><td class="paramname">out_data</td><td><code>size_t</code> a buffer large enough to contain the encrypted or decrypted data. The amount of data written may be anything from zero bytes to (remaining_sz + cipher_block_size - 1). </td></tr>
    <tr><td class="paramname">out_sz</td><td><code>size_t</code> the number of bytes written to out_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga76ce23781acaeef6afa376c4b7983398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ce23781acaeef6afa376c4b7983398">&#9670;&nbsp;</a></span>GDCipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>in_data_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform encryption or decryption of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> a pointer to the cipher context. </td></tr>
    <tr><td class="paramname">out_data</td><td><code>void*</code> a buffer large enough to contain the encrypted or decrypted data. The amount of data written may be anything from zero bytes to (in_sz + cipher_block_size - 1). </td></tr>
    <tr><td class="paramname">in_data</td><td><code>const void*</code> a pointer to the data to be encrypted or decrypted. </td></tr>
    <tr><td class="paramname">in_data_sz</td><td><code>unsigned int</code> the number of bytes of the data to be encrypted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gada41794300643ff312c31d5b7fdcecec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada41794300643ff312c31d5b7fdcecec">&#9670;&nbsp;</a></span>GDCipher_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDCipher_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all information from a cipher context and frees up any allocated memory associate with it. It should be called after all operations using a cipher are complete so sensitive information does not remain in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> a pointer to the cipher context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gae1bcce9e8c309f54807d2345a7533ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1bcce9e8c309f54807d2345a7533ace">&#9670;&nbsp;</a></span>GDCipher_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDCipher_free </td>
          <td>(</td>
          <td class="paramtype">struct GDCipherContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate cipher context resources. It does not free the buffer holding the encrypted or decrypted data that the caller supplied to <a class="el" href="group__cryptolist.html#ga78b831846627eff0e346332b615a84f3" title="Encipher or decipher last block.">GDCipher_final()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDCipherContext*</code> a pointer to the cipher context to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad071d12fb3d072441ad058fb3934293e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad071d12fb3d072441ad058fb3934293e">&#9670;&nbsp;</a></span>GDDigest_byname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a>* GDDigest_byname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a digest algorithm structure by name. The name must be the long name format as specified in obj_mac.h of OpenSSL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td><code>char*</code> the name of the digest required. For example, "sha256". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the digest or NULL. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga11d464d593efe47baf9b68cc6906cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d464d593efe47baf9b68cc6906cf5f">&#9670;&nbsp;</a></span>GDDigest_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GDDigest_name </td>
          <td>(</td>
          <td class="paramtype">const struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the given digest structure. The name will be in long name format as specified in obj_mac.h of OpenSSL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> the digest context for which the name is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>char*</code> the digest name or NULL. </dd></dl>

</div>
</div>
<a id="gaf8ba8398be10277e296a6dba119a0126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ba8398be10277e296a6dba119a0126">&#9670;&nbsp;</a></span>GDDigest_bycontext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a>* GDDigest_bycontext </td>
          <td>(</td>
          <td class="paramtype">const struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a digest structure for the given digest context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> the context of the digest required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDDigest*</code> the digest or NULL. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga83b33c5aaf906165060a7c9d5cefa4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b33c5aaf906165060a7c9d5cefa4f6">&#9670;&nbsp;</a></span>GDDigest_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the specified digest size in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest</td><td><code>const GDDigest* digest</code> the digest. For example, "sha256". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the digest size. </dd></dl>

</div>
</div>
<a id="gaccb3ee6e8ee908ba72a96d4235685388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb3ee6e8ee908ba72a96d4235685388">&#9670;&nbsp;</a></span>GDDigest_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the block size of a given digest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest</td><td><code>GDCipher*</code> the digest for which the block size is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the block size of the digest in bytes. </dd></dl>

</div>
</div>
<a id="ga990ac7fb4c04ee68da737ae8ee920a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga990ac7fb4c04ee68da737ae8ee920a54">&#9670;&nbsp;</a></span>GDDigest_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDDigestContext* GDDigest_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A digest context is used to calculate the digest (hash) of a message. The context should be initialized with a specific digest algorithm by calling <a class="el" href="group__cryptolist.html#gaa50948df9ca3607ccccad176e8e2fce1" title="Initialize a digest context.">GDDigest_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDDigestContext*</code> a digest context. </dd></dl>

</div>
</div>
<a id="gaa50948df9ca3607ccccad176e8e2fce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa50948df9ca3607ccccad176e8e2fce1">&#9670;&nbsp;</a></span>GDDigest_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_init </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the digest context with a specific digest algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> a pointer to the digest context. </td></tr>
    <tr><td class="paramname">algorithm</td><td><code>const GDDigest*</code> the digest algorithm, for example SHA-256. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga01595eda382b2bb3c4e4013f01f985d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01595eda382b2bb3c4e4013f01f985d1">&#9670;&nbsp;</a></span>GDDigest_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_copy </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the digest context. The destination digest is cleaned up before being updated to match the source digest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><code>GDDigestContext*</code> a pointer to a digest context. </td></tr>
    <tr><td class="paramname">destination</td><td><code>const GDDigestContext*</code> the digest context to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gae12bd434ec509eb679e02a6795581d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae12bd434ec509eb679e02a6795581d2a">&#9670;&nbsp;</a></span>GDDigest_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_update </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>message_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the digest of a message. This function can be called multiple times to update the digest with additional message data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> a pointer to the digest context. </td></tr>
    <tr><td class="paramname">message</td><td><code>const void*</code> a pointer to the message chunk. </td></tr>
    <tr><td class="paramname">message_sz</td><td><code>size_t</code> the number of bytes of the message chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gaa71b7654927012982e6a477dc3ecb844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa71b7654927012982e6a477dc3ecb844">&#9670;&nbsp;</a></span>GDDigest_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_final </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>digest_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the final digest of the complete message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> a pointer to the digest context. </td></tr>
    <tr><td class="paramname">digest</td><td><code>void*</code> a pointer to memory large enough to contain the digest. The caller must allocate and eventually free this buffer. The size of the buffer required can be determined by calling <a class="el" href="group__cryptolist.html#ga83b33c5aaf906165060a7c9d5cefa4f6" title="Size of a digest in bytes.">GDDigest_size()</a>, or using GDDIGEST_MAX_SIZE. </td></tr>
    <tr><td class="paramname">digest_sz</td><td><code>size_t</code> the number of digest bytes copied to digest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga88753feb89e59dd74163c293c4ec8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88753feb89e59dd74163c293c4ec8d83">&#9670;&nbsp;</a></span>GDDigest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>md_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDDigest *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the digest of a message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><code>const void*</code> a buffer containing the data to hash. </td></tr>
    <tr><td class="paramname">data_sz</td><td><code>size_t</code> the size of the buffer containing the data to hash. </td></tr>
    <tr><td class="paramname">md</td><td><code>void*</code> a buffer large enough to contain the digest. </td></tr>
    <tr><td class="paramname">md_sz</td><td><code>size_t</code> upon return, the number of bytes of the calculated digest. </td></tr>
    <tr><td class="paramname">type</td><td><code>GDDigest*</code> the digest required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="gad0e89a3fa76754ee4a081ebfdcd726e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e89a3fa76754ee4a081ebfdcd726e1">&#9670;&nbsp;</a></span>GDDigest_sign_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_sign_init </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKeyContext **&#160;</td>
          <td class="paramname"><em>key_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a digest context for a signing operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> the digest context to initialize. </td></tr>
    <tr><td class="paramname">key_context</td><td><code>GDKeyContext**</code> if not NULL, upon return, a key context that can be used to set additional signing parameters. The key context will be freed automatically when the digest context is freed. </td></tr>
    <tr><td class="paramname">digest</td><td><code>GDDigest*</code> the digest algorithm to use when signing. </td></tr>
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the signer's private key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 or a negative value for failure. </dd></dl>

</div>
</div>
<a id="gacbfe65af0dc09e5b25b68be7272220eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbfe65af0dc09e5b25b68be7272220eb">&#9670;&nbsp;</a></span>GDDigest_sign_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_sign_final </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>signature_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signs a message digest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> the initialized digest context to use when signing. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> a buffer large enough to contain the signature. If NULL, the size required is returned in signature_sz. </td></tr>
    <tr><td class="paramname">signature_sz</td><td><code>GDDigest*</code> upon return, the size of the signature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success and 0 or a negative value for failure. </dd></dl>

</div>
</div>
<a id="ga9c574cbd428f62f2a21f450ed8606a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c574cbd428f62f2a21f450ed8606a66">&#9670;&nbsp;</a></span>GDDigest_verify_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_verify_init </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKeyContext **&#160;</td>
          <td class="paramname"><em>key_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a digest context for a verification operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> the digest context to initialize. </td></tr>
    <tr><td class="paramname">key_ctx</td><td><code>GDKeyContext**</code> if not NULL, upon return, a key context that can be used to set additional verification parameters. The key context will be freed automatically when the digest context is freed. </td></tr>
    <tr><td class="paramname">digest</td><td><code>GDDigest*</code> the digest algorithm to use when verifying. </td></tr>
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the signer's public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga627c39856bae844c89ef6c010e05f91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627c39856bae844c89ef6c010e05f91a">&#9670;&nbsp;</a></span>GDDigest_verify_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_verify_final </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>signature_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies a message digest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> the initialized digest context to use for verification. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> a buffer containing a signature. </td></tr>
    <tr><td class="paramname">signature_sz</td><td><code>GDDigest*</code> the size of the signature buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for successful verification, 0 for verification failure (not an error - message or signature is not to be trusted), or a negative value for a more serious error. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga02e79b75925417b9615d420bbfa89629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02e79b75925417b9615d420bbfa89629">&#9670;&nbsp;</a></span>GDDigest_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDDigest_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all information from a digest context and frees up any allocated memory associate with it. It should be called after all operations using a digest are complete so sensitive information does not remain in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> a pointer to the digest context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga98e7a9cd1a9642506442675e8d8ba04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e7a9cd1a9642506442675e8d8ba04b">&#9670;&nbsp;</a></span>GDDigest_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDDigest_free </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate digest context resources. It does not free the digest buffer that the caller supplied to <a class="el" href="group__cryptolist.html#gaa71b7654927012982e6a477dc3ecb844" title="Finalize and output the digest.">GDDigest_final()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDDigestContext*</code> a pointer to the digest context to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1603708f721422f770341800d8a00008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1603708f721422f770341800d8a00008">&#9670;&nbsp;</a></span>GDCryptoError_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long GDCryptoError_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the earliest error code from the thread's error stack and removes the entry. This function can be called repeatedly until there are no more error codes to return.</p>
<dl class="section return"><dt>Returns</dt><dd><code>unsigned long</code> an error code, or 0 if there is no error in the queue. </dd></dl>

</div>
</div>
<a id="ga1f40984b35d40779b302f0e4356bb62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f40984b35d40779b302f0e4356bb62a">&#9670;&nbsp;</a></span>GDCryptoError_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long GDCryptoError_peek </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the earliest error code without modifying the error stack for this thread.</p>
<dl class="section return"><dt>Returns</dt><dd><code>unsigned long</code> The error code, or 0 if there is no error in the queue. </dd></dl>

</div>
</div>
<a id="gad3ff150afbef5e9f3879bce5f81d79be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ff150afbef5e9f3879bce5f81d79be">&#9670;&nbsp;</a></span>GDCryptoError_peek_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long GDCryptoError_peek_last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the latest error code without modifying the error stack for this thread.</p>
<dl class="section return"><dt>Returns</dt><dd><code>unsigned long</code> The error code, or 0 if there is no error in the queue. </dd></dl>

</div>
</div>
<a id="gaa8ba8f1303ac100812693cb5841a56ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8ba8f1303ac100812693cb5841a56ee">&#9670;&nbsp;</a></span>GDCryptoError_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDCryptoError_clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the thread's error stack. </p>

</div>
</div>
<a id="ga33eb1f64dc931bf5edcc2d8c65fc1081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33eb1f64dc931bf5edcc2d8c65fc1081">&#9670;&nbsp;</a></span>GDCryptoError_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GDCryptoError_string </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a human-readable string representing the error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td><code>unsigned long</code> the error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>char*</code> a pointer to a static buffer containing the string. </dd></dl>

</div>
</div>
<a id="gad39eea112baae1cf8dad0a7836ca6047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad39eea112baae1cf8dad0a7836ca6047">&#9670;&nbsp;</a></span>GDCryptoError_detailed_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GDCryptoError_detailed_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a human-readable string with additional technical information if avaiable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>char*</code> a pointer to a static buffer containing the string. </dd></dl>

</div>
</div>
<a id="ga2c98f717b0c30fc44c739f7b969466b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c98f717b0c30fc44c739f7b969466b5">&#9670;&nbsp;</a></span>GDFIPS_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDFIPS_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the FIPS mode of operation. When in FIPS mode, calls to the Dynamics Crypto API will fail if an algorithm not compliant with FIPS 140-2 is used.</p>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> A return code of non-zero indicates FIPS mode, 0 indicates non-FIPS mode. </dd></dl>

</div>
</div>
<a id="ga817dd75ea1ca9b7a5228666ac08a13d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817dd75ea1ca9b7a5228666ac08a13d1">&#9670;&nbsp;</a></span>GDX509_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509* GDX509_copy </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy resources held by the X509 structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the X509 structure to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga603ad0c14f7b24613f7325234c5b3bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603ad0c14f7b24613f7325234c5b3bd6">&#9670;&nbsp;</a></span>GDX509_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDX509_free </td>
          <td>(</td>
          <td class="paramtype">struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates resources held by the X509 structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the X509 structure to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e2d56061f2544a2171c751b381c37d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e2d56061f2544a2171c751b381c37d9">&#9670;&nbsp;</a></span>GDX509List_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_read </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pem_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes a PEM container and returns a list of certificates within.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pem</td><td><code>const char*</code> a pointer to the PEM data. </td></tr>
    <tr><td class="paramname">pem_length</td><td><code>int</code> length of the PEM data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> the list of certificates within the PEM data. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gaa5625e7158a7c606620842395e991dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5625e7158a7c606620842395e991dd5">&#9670;&nbsp;</a></span>GDX509List_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_copy </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies and returns a list of certificates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> the list to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> the copied list of certificates. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gac962c11e1f5c377581a78b8a24a135a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac962c11e1f5c377581a78b8a24a135a9">&#9670;&nbsp;</a></span>GDX509List_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDX509List_num </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of X509 certificates within a list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> the list of certificates to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the number of certificates within the list. </dd></dl>

</div>
</div>
<a id="gaa154c775230df5c19cdf5ff46c12f5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa154c775230df5c19cdf5ff46c12f5df">&#9670;&nbsp;</a></span>GDX509List_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct GDX509* GDX509List_value </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an X509 certificate at a zero-based index within the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> the list of certificates to access. </td></tr>
    <tr><td class="paramname">index</td><td><code>int</code> the index of list to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509*</code> the certificate at the specified index. </dd></dl>

</div>
</div>
<a id="ga4ea5c06ff6d86b85fbed877488bae482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea5c06ff6d86b85fbed877488bae482">&#9670;&nbsp;</a></span>GDX509List_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDX509List_insert </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies and inserts a X509 certificate into a list at a given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> the list of certificates to insert into. </td></tr>
    <tr><td class="paramname">index</td><td><code>int</code> the index within the list to insert the certificate. </td></tr>
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the certificate to copy and insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga425c53964c61d443256ffdf2cd774f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425c53964c61d443256ffdf2cd774f4f">&#9670;&nbsp;</a></span>GDX509List_evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDX509List_evaluate </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>not_used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates whether the certificate can be trusted. A certificate is trustworthy if an unbroken chain of trust back to the root Certificate Authority (CA) within the trust store can be established. Validity periods and signatures of the leaf certificate and intermediates (if any) are checked.</p>
<p>The Dynamics trust store will be searched first, and if the device certificate store is enabled it may also be used during evaluation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> the certificate to evaluate, followed by intermediates (if any). </td></tr>
    <tr><td class="paramname">not_used</td><td><code>GDX509List*</code> must be NULL. </td></tr>
    <tr><td class="paramname">hostname</td><td><code>char*</code> the name of the server if used to evaluate a TLS server certificate. </td></tr>
    <tr><td class="paramname">reason</td><td><code>char**</code> allocated and set to the reason for failure upon return, NULL otherwise. The caller is responsible for deallocating by calling free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>bool</code> true if the certificate chain is trusted, false otherwise. </dd></dl>

</div>
</div>
<a id="gae5d36d0a39dcef094377330d2a09f7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d36d0a39dcef094377330d2a09f7fb">&#9670;&nbsp;</a></span>GDX509List_trusted_authorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_trusted_authorities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of trusted certificate authorities found within the Dynamics container.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of trusted certificate authorities or NULL if not found. </dd></dl>

</div>
</div>
<a id="gaa21fb824924dcedb2f5211fe1189d656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21fb824924dcedb2f5211fe1189d656">&#9670;&nbsp;</a></span>GDX509List_all_user_certs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_all_user_certs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of user certificates known to Dynamics.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of all user certificates known to Dynamics, NULL if none. </dd></dl>

</div>
</div>
<a id="ga1a219d6cfb7ebb865a3fca0b7d78ff2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a219d6cfb7ebb865a3fca0b7d78ff2e">&#9670;&nbsp;</a></span>GDX509List_valid_user_signing_certs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_valid_user_signing_certs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of user certificates known to Dynamics if the device's time falls within the certificate's validity date range.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of all valid user certificates known to Dynamics, NULL if none. </dd></dl>

</div>
</div>
<a id="ga7bb65bee2c652d2f18317cfddf08cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb65bee2c652d2f18317cfddf08cd5c">&#9670;&nbsp;</a></span>GDX509List_valid_user_encryption_certs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_valid_user_encryption_certs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of user certificates known to Dynamics if the device's time falls within the certificate's validity date range, and usage properties permit it to be used for encryption purposes.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of all valid user encryption certificates known to Dynamics, NULL if none. </dd></dl>

</div>
</div>
<a id="ga80764272a700a06e273741aba77a8fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80764272a700a06e273741aba77a8fea">&#9670;&nbsp;</a></span>GDX509List_all_user_encryption_certs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_all_user_encryption_certs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of user certificates known to Dynamics if usage properties permit it to be used for encryption purposes. The list may include expired certificates.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of all user encryption certificates known to Dynamics, NULL if none. </dd></dl>

</div>
</div>
<a id="gabd651b0cd95117c99b7c423afa4e3354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd651b0cd95117c99b7c423afa4e3354">&#9670;&nbsp;</a></span>GDX509List_aux_certs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDX509List* GDX509List_aux_certs </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a certificate chain for the user certificate, containing intermediate certificates, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the user certificates for which the chain is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of intermediate certificates or NULL if none. </dd></dl>

</div>
</div>
<a id="ga92ddd08f6b1c371c3e784dfa2f90f613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ddd08f6b1c371c3e784dfa2f90f613">&#9670;&nbsp;</a></span>GDX509List_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDX509List_free </td>
          <td>(</td>
          <td class="paramtype">struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates resources held by the X509 list structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> the X509 list structure to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf4d11701b4eacbba17999067925a4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf4d11701b4eacbba17999067925a4d3">&#9670;&nbsp;</a></span>GDKey_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDKey* GDKey_public </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the public key from within the supplied certificate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the certificate for which the key is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDKey*</code> the public key of the certificate. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gabdecd54690f6a55a024bb049dc2626d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdecd54690f6a55a024bb049dc2626d1">&#9670;&nbsp;</a></span>GDKey_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDKey* GDKey_private </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the private key corresponding to a user certificate stored within the Dynamics Key Store. The key data is not meaningful and will yield garbage if used to sign or decrypt data using external (non-Dynamics) APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the certificate for which the private key is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDKey*</code> the private key of the certificate. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga4b4cc18f8a0358eca02db69213060195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b4cc18f8a0358eca02db69213060195">&#9670;&nbsp;</a></span>GDKey_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDKey_free </td>
          <td>(</td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates resources held by the key structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the key structure to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3faa39d13b07e6741d4913eb726d3465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3faa39d13b07e6741d4913eb726d3465">&#9670;&nbsp;</a></span>GDKey_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_compare </td>
          <td>(</td>
          <td class="paramtype">const struct GDKey *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDKey *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><code>GDKey*</code> key a. </td></tr>
    <tr><td class="paramname">b</td><td><code>GDKey*</code> key b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 if the keys match, 0 if they don't match, -1 if the key types are different and -2 if the operation is not supported. </dd></dl>

</div>
</div>
<a id="ga5c6e2f58acb9b176f5776e4f0b319992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6e2f58acb9b176f5776e4f0b319992">&#9670;&nbsp;</a></span>GDKey_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_size </td>
          <td>(</td>
          <td class="paramtype">const struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum size of an ASN.1 encoded signature in bytes. It can be used to determine how much memory must be allocated for a signature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the key for which the signature size is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the maximum signature size in bytes. </dd></dl>

</div>
</div>
<a id="gac065a80e0e78833217a8a6c8abb74c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac065a80e0e78833217a8a6c8abb74c6e">&#9670;&nbsp;</a></span>GDKey_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_bits </td>
          <td>(</td>
          <td class="paramtype">const struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the key size in bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the key for which the size is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the key size in bits. </dd></dl>

</div>
</div>
<a id="ga41a85a056ae70f0840723a057181dd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a85a056ae70f0840723a057181dd0a">&#9670;&nbsp;</a></span>GDKey_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_type </td>
          <td>(</td>
          <td class="paramtype">const struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of the underlying key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the key for which the type is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the key type, which will be either GDKEY_TYPE_RSA, GDKEY_TYPE_DSA, or GDKEY_TYPE_EC. </dd></dl>

</div>
</div>
<a id="ga1c9b4c61ef8fcfd7c248bde9a352940d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9b4c61ef8fcfd7c248bde9a352940d">&#9670;&nbsp;</a></span>GDKey_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GDKey_name </td>
          <td>(</td>
          <td class="paramtype">const struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the key algorithm name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the key for which the algorithm name is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>char*</code> the key algorithm name. </dd></dl>

</div>
</div>
<a id="ga6ec8e3da768ae7621d21ddb962fd0275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec8e3da768ae7621d21ddb962fd0275">&#9670;&nbsp;</a></span>GDKeyContext_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDKeyContext* GDKeyContext_new </td>
          <td>(</td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new key context object. Contexts are opaque structures used by other APIs and must not be used simultaneously by multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the key for which the context is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDKeyContext*</code> the key context or NULL if an error occurred. </dd></dl>

</div>
</div>
<a id="ga242e61bfbcec060da52802330b92e912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242e61bfbcec060da52802330b92e912">&#9670;&nbsp;</a></span>GDKeyContext_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDKeyContext* GDKeyContext_copy </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a key context object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKey*</code> the source key context to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDKeyContext*</code> a copy of the key context. </dd></dl>

</div>
</div>
<a id="gaa5b12a5cd6d9f88791da0b865a4e0454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b12a5cd6d9f88791da0b865a4e0454">&#9670;&nbsp;</a></span>GDKeyContext_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDKeyContext_free </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates resources held by the key context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82df88f30fb770da2dc1c10e3a7a34ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82df88f30fb770da2dc1c10e3a7a34ab">&#9670;&nbsp;</a></span>GDKey_sign_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_sign_init </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a key context object for a signing operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success and 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga4a6a00ed83e2ea32b869e0fd305021e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a6a00ed83e2ea32b869e0fd305021e2">&#9670;&nbsp;</a></span>GDKey_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_sign </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>signature_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>message_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signs a message, usually a message digest and returns the ASN.1 DER encoded signature. This function does not calculate the digest of the data to be signed. The required size for the signature buffer can be computed by calling this function with a NULL signature buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to sign with. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> NULL, or a buffer large enough to hold the signature. </td></tr>
    <tr><td class="paramname">signature_length</td><td><code>size_t*</code> must be set to the length of the signature buffer, and upon return will be set to the amount of data written to the signature buffer. If signature is NULL, it will be set to the maximum size of the signature. </td></tr>
    <tr><td class="paramname">message</td><td><code>void*</code> the message to sign, usually a digest. </td></tr>
    <tr><td class="paramname">message_length</td><td><code>size_t*</code> the length of the message to sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success and 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gadedb564fbb6cd9c5a0220d1c5b38a288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadedb564fbb6cd9c5a0220d1c5b38a288">&#9670;&nbsp;</a></span>GDKey_verify_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_verify_init </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a key context object for a verification operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success and 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga8c7f18114b4d81cf3fae2023706cf416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7f18114b4d81cf3fae2023706cf416">&#9670;&nbsp;</a></span>GDKey_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_verify </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>signature_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>message_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifys an ASN.1 DER encoded signature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to verify with. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> a buffer holding the signature. </td></tr>
    <tr><td class="paramname">signature_length</td><td><code>size_t*</code> the length of the signature. </td></tr>
    <tr><td class="paramname">message</td><td><code>void*</code> a buffer holding the message or digest to be verified. </td></tr>
    <tr><td class="paramname">message_length</td><td><code>size_t*</code> the length of the message or digest to verify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for successful verification, 0 for verification failure (not an error - message or signature is not to be trusted), or a negative value for a more serious error. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gaf311586c241be32565544012d0255cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf311586c241be32565544012d0255cbe">&#9670;&nbsp;</a></span>GDKey_encrypt_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_encrypt_init </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a key context object for an encryption operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success and 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gab4b1056fdb80168e2514867a9c03f624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b1056fdb80168e2514867a9c03f624">&#9670;&nbsp;</a></span>GDKey_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_encrypt </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encrypted_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>clear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>clear_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encrypts data using the key associated with the supplied key context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to encrypt with. </td></tr>
    <tr><td class="paramname">encrypted</td><td><code>void*</code> a buffer large enough to hold the encrypted data. If NULL, the length required is returned in encrypted_length. </td></tr>
    <tr><td class="paramname">encrypted_length</td><td><code>size_t*</code> the length of the buffer supplied to hold the encrypted data, and upon successful return the actual length of the encrypted data. </td></tr>
    <tr><td class="paramname">clear</td><td><code>void*</code> the data to encrypt. </td></tr>
    <tr><td class="paramname">clear_length</td><td><code>size_t*</code> the length of the data to encrypt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gafb0c995685fa179294a6db48c5d6a55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb0c995685fa179294a6db48c5d6a55e">&#9670;&nbsp;</a></span>GDKey_decrypt_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_decrypt_init </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a key context object for a decryption operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success and 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gaf7afd23d01738d6078485997452d8312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7afd23d01738d6078485997452d8312">&#9670;&nbsp;</a></span>GDKey_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_decrypt </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>clear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>clear_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>encrypted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encrypted_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrypts data using the key associated with the supplied key context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to decrypt with. </td></tr>
    <tr><td class="paramname">clear</td><td><code>void*</code> a buffer large enough to hold the decrypted data. If NULL, the length required is returned in clear_length. </td></tr>
    <tr><td class="paramname">clear_length</td><td><code>size_t*</code> the length of the buffer supplied to hold the decrypted data, and upon successful return the actual length of the decrypted data. </td></tr>
    <tr><td class="paramname">encrypted</td><td><code>void*</code> the data to decrypt. </td></tr>
    <tr><td class="paramname">encrypted_length</td><td><code>size_t*</code> the length of the data to decrypt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 or a negative value for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga50a65c0a8c43b2537cc976c287f4a23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a65c0a8c43b2537cc976c287f4a23c">&#9670;&nbsp;</a></span>GDKey_sign_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_sign_final </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>signature_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signs a message digest. The output signature buffer size can be computed by calling <a class="el" href="group__cryptolist.html#ga5c6e2f58acb9b176f5776e4f0b319992" title="Signature size.">GDKey_size()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest</td><td><code>GDDigestContext*</code> the initialized digest context. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> a buffer large enough to hold the signature at least GDKey_size(key) bytes. </td></tr>
    <tr><td class="paramname">signature_length</td><td><code>unsigned int*</code> upon successful return will be set to the amount of data written to the signature buffer. </td></tr>
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the private signing key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success and 0 for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga125066dbdb13f1e2c2c766c04b537b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125066dbdb13f1e2c2c766c04b537b04">&#9670;&nbsp;</a></span>GDKey_verify_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_verify_final </td>
          <td>(</td>
          <td class="paramtype">struct GDDigestContext *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>signature_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies a message digest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest</td><td><code>GDDigestContext*</code> the initialized digest context to verify. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> a buffer containing the DER encoded signature. </td></tr>
    <tr><td class="paramname">signature_length</td><td><code>unsigned int</code> the length of the signature buffer in bytes. </td></tr>
    <tr><td class="paramname">key</td><td><code>GDKey*</code> the signer's public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for successful verification, 0 for verification failure (not an error - message or signature is not to be trusted), or a negative value for a more serious error. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga16cb9f1eac95e253060d3a82396566ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16cb9f1eac95e253060d3a82396566ca">&#9670;&nbsp;</a></span>GDKey_set_signature_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_set_signature_md </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the digest algorithm to be used when calculating a signature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to setup. </td></tr>
    <tr><td class="paramname">digest</td><td><code>GDDigest*</code> the digest algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gaf195d55d54f92da1f0a91fe9d4da2593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf195d55d54f92da1f0a91fe9d4da2593">&#9670;&nbsp;</a></span>GDKey_get_signature_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDKey_get_signature_md </td>
          <td>(</td>
          <td class="paramtype">struct GDKeyContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> **&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the digest algorithm for a given key context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>GDKeyContext*</code> the key context to query. </td></tr>
    <tr><td class="paramname">digest</td><td><code>GDDigest**</code> the digest algorithm returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 for failure. The reason for failure can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gafd8d2fccf52a833bf03d9f18b14f5ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8d2fccf52a833bf03d9f18b14f5ad6">&#9670;&nbsp;</a></span>GDPKCS7_SMIME_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDPKCS7* GDPKCS7_SMIME_read </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream **&#160;</td>
          <td class="paramname"><em>clearText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserialize SMIME content received over a network, read from a file, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to read the SMIME message from. </td></tr>
    <tr><td class="paramname">clearText</td><td><code>GDStream**</code> if cleartext signing is used then the content is returned in a memory stream, otherwise *clearText is set to NULL. The caller is responsible for freeing the stream. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDPKCS7*</code> a PKCS7 structure or NULL if an error occurred. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga4512a991eb135ffed09ee7f815062b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4512a991eb135ffed09ee7f815062b50">&#9670;&nbsp;</a></span>GDPKCS7_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDPKCS7* GDPKCS7_read </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserialize ASN.1/DER encoded PKCS7 content received over a network, read from a file, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to read the ASN.1/DER encoded data from. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDPKCS7*</code> a PKCS7 structure or NULL if an error occurred. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga7860d200df33e48af0064bd5bad459bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7860d200df33e48af0064bd5bad459bb">&#9670;&nbsp;</a></span>GDPKCS7_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDPKCS7_type </td>
          <td>(</td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the type of the PKCS7 structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 structure to verify. The PKCS7 structure may be obtained from an initial call to <a class="el" href="group__cryptolist.html#ga4512a991eb135ffed09ee7f815062b50" title="Deserialize ASN.1/DER encoding to a PKCS7 structure.">GDPKCS7_read()</a>, <a class="el" href="group__cryptolist.html#ga1671a701935fd5d7ed1856ace0c2e42f" title="Create a PKCS7 envelopedData structure.">GDPKCS7_encrypt()</a>, or <a class="el" href="group__cryptolist.html#gaafa146b39ea5ed4d514cfb9f77423f21" title="Add signer information to a PKCS7 structure.">GDPKCS7_add_signer()</a>. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the type of the PKCS7 structure. </dd></dl>

</div>
</div>
<a id="gaa486dacc671585715da0b3fba02e5789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa486dacc671585715da0b3fba02e5789">&#9670;&nbsp;</a></span>GDPKCS7_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDPKCS7_verify </td>
          <td>(</td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDX509List *&#160;</td>
          <td class="paramname"><em>anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies a PKCS7 signedData structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 structure to verify. The PKCS7 structure may be obtained from an initial call to <a class="el" href="group__cryptolist.html#ga4512a991eb135ffed09ee7f815062b50" title="Deserialize ASN.1/DER encoding to a PKCS7 structure.">GDPKCS7_read()</a>. </td></tr>
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> a set of certificates in which to search for the signer's certificate. </td></tr>
    <tr><td class="paramname">anchors</td><td><code>GDX509List*</code> an optional set of trusted certificate authorities or NULL if using the Dynamics trusted certificate store. </td></tr>
    <tr><td class="paramname">indata</td><td><code>GDStream*</code> the signed data if the content is detached. </td></tr>
    <tr><td class="paramname">out</td><td><code>GDStream*</code> the content is written to out if it is not NULL. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for a successful verification and 0 if an error occurs. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga7f2d883fc7f056a87fdd07eb45115d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f2d883fc7f056a87fdd07eb45115d23">&#9670;&nbsp;</a></span>GDPKCS7_get_signers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct GDX509List* GDPKCS7_get_signers </td>
          <td>(</td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the signer's certificate(s) from a PKCS7 signedData structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 signedData. The PKCS7 structure may be obtained from an initial call to <a class="el" href="group__cryptolist.html#ga4512a991eb135ffed09ee7f815062b50" title="Deserialize ASN.1/DER encoding to a PKCS7 structure.">GDPKCS7_read()</a>. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDX509List*</code> a list of end-user certificates belonging to the signer(s), or NULL. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gace9255f52b83769c2047d0c07148df2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9255f52b83769c2047d0c07148df2a">&#9670;&nbsp;</a></span>GDPKCS7_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDPKCS7_decrypt </td>
          <td>(</td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>pkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrypts content within a PKCS7 envelopedData structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 envelopedData structure to decrypt. </td></tr>
    <tr><td class="paramname">pkey</td><td><code>GDKey*</code> private key of the recipient. </td></tr>
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the recipients certificate. </td></tr>
    <tr><td class="paramname">data</td><td><code>GDStream*</code> the decrypted content is written to data. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> either 1 for success or 0 for failure. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga1671a701935fd5d7ed1856ace0c2e42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1671a701935fd5d7ed1856ace0c2e42f">&#9670;&nbsp;</a></span>GDPKCS7_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDPKCS7* GDPKCS7_encrypt </td>
          <td>(</td>
          <td class="paramtype">struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga76ce23781acaeef6afa376c4b7983398">GDCipher</a> *&#160;</td>
          <td class="paramname"><em>cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and return an encrypted PKCS7 envelopedData structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> a list of recipient certificates. </td></tr>
    <tr><td class="paramname">in</td><td><code>GDStream*</code> the content to be encrypted. </td></tr>
    <tr><td class="paramname">cipher</td><td><code>GDCipher*</code> the symmetric cipher to use. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDPKCS7*</code> a PKCS7 structure or NULL if an error occurred. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gaafa146b39ea5ed4d514cfb9f77423f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa146b39ea5ed4d514cfb9f77423f21">&#9670;&nbsp;</a></span>GDPKCS7_add_signer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDPKCS7* GDPKCS7_add_signer </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>signcert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDKey *&#160;</td>
          <td class="paramname"><em>pkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDX509List *&#160;</td>
          <td class="paramname"><em>certs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>md</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add signer information and return a PKCS7 signedData structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signcert</td><td><code>GDX509*</code> the signing certificate. </td></tr>
    <tr><td class="paramname">pkey</td><td><code>GDKey*</code> the corresponsding private key of the signing certificate. </td></tr>
    <tr><td class="paramname">certs</td><td><code>GDX509List*</code> optional additional set of certificates to include in the PKCS7 structure, for example, intermediate CAs. </td></tr>
    <tr><td class="paramname">md</td><td><code>GDDigest*</code> the message digest to use. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDPKCS7*</code> a PKCS7 structure or NULL if an error occurred. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga204e54a49c04910f06a649ddd4c77903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204e54a49c04910f06a649ddd4c77903">&#9670;&nbsp;</a></span>GDPKCS7_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDPKCS7_final </td>
          <td>(</td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalize a PKCS7 structure, readying it for serialization. This may trigger computation of the actual PKCS7 data, such as content signing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 structure to finalize. </td></tr>
    <tr><td class="paramname">data</td><td><code>GDStream*</code> the content to be finalized. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> either 1 for success or 0 for failure. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gad56847d709eb1de5d0cffd07cca231ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56847d709eb1de5d0cffd07cca231ef">&#9670;&nbsp;</a></span>GDPKCS7_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDPKCS7_write </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize a PKCS7 structure to ASN.1/DER encoding suitable for sending over the network, writing to a file, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to write the ASN.1/DER encoded data to. </td></tr>
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 structure to serialize. The PKCS7 structure may be obtained from an initial call to <a class="el" href="group__cryptolist.html#gaafa146b39ea5ed4d514cfb9f77423f21" title="Add signer information to a PKCS7 structure.">GDPKCS7_add_signer()</a> or <a class="el" href="group__cryptolist.html#ga1671a701935fd5d7ed1856ace0c2e42f" title="Create a PKCS7 envelopedData structure.">GDPKCS7_encrypt()</a>. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> either 1 for success or 0 for failure. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga239be66e49caea7a77a495d5b3410903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239be66e49caea7a77a495d5b3410903">&#9670;&nbsp;</a></span>GDPKCS7_SMIME_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDPKCS7_SMIME_write </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize a PKCS7 structure to SMIME encoding suitable for sending over the network, writing to a file, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to write the SMIME message to. </td></tr>
    <tr><td class="paramname">data</td><td><code>GDStream*</code> the content to read from if streaming is enabled. </td></tr>
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 structure to serialize. The PKCS7 structure may be obtained from an initial call to <a class="el" href="group__cryptolist.html#gaafa146b39ea5ed4d514cfb9f77423f21" title="Add signer information to a PKCS7 structure.">GDPKCS7_add_signer()</a> or <a class="el" href="group__cryptolist.html#ga1671a701935fd5d7ed1856ace0c2e42f" title="Create a PKCS7 envelopedData structure.">GDPKCS7_encrypt()</a>. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> either 1 for success or 0 for failure. The error can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gabc30ba55ac0922ffc4a45aeb0060ed81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc30ba55ac0922ffc4a45aeb0060ed81">&#9670;&nbsp;</a></span>GDPKCS7_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDPKCS7_free </td>
          <td>(</td>
          <td class="paramtype">struct GDPKCS7 *&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates resources held by the PKCS7 structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p7</td><td><code>GDPKCS7*</code> the PKCS7 structure to free. </td></tr>
    <tr><td class="paramname">flags</td><td><code>int</code> optional set of flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3468e3058119ca607c938cd7c374aacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3468e3058119ca607c938cd7c374aacf">&#9670;&nbsp;</a></span>GDRSA_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDRSA* GDRSA_public_key </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gacf4d11701b4eacbba17999067925a4d3" title="Retrieve the public key.">GDKey_public()</a>.</dd></dl>
<p>Return the RSA public key from within the supplied certificate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the certificate for which the key is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDRSA*</code> the public key of the certificate. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga7a317239a17c7a77c0988b7e8f9447ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a317239a17c7a77c0988b7e8f9447ff">&#9670;&nbsp;</a></span>GDRSA_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDRSA* GDRSA_private_key </td>
          <td>(</td>
          <td class="paramtype">const struct GDX509 *&#160;</td>
          <td class="paramname"><em>cert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gabdecd54690f6a55a024bb049dc2626d1" title="Retrieve an opaque private key corresponding to a user certificate.">GDKey_private()</a>.</dd></dl>
<p>Return the private RSA key corresponding to a user certificate. The key data is not meaningful and will yield garbage if used to sign or decrypt data using non-Dynamics APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td><code>GDX509*</code> the certificate for which the private key is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDRSA*</code> the RSA private key of the certificate. If NULL, the reason can be obtained from <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga185500055c023cbbfd1a6b6bcc2c79fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185500055c023cbbfd1a6b6bcc2c79fb">&#9670;&nbsp;</a></span>GDRSA_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_size </td>
          <td>(</td>
          <td class="paramtype">const struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#ga5c6e2f58acb9b176f5776e4f0b319992" title="Signature size.">GDKey_size()</a>.</dd></dl>
<p>Returns the RSA modulus size in bytes. It can be used to determine how much memory must be allocated for an RSA encrypted value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the RSA key for which the modulus size is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> the RSA modulus size in bytes. </dd></dl>

</div>
</div>
<a id="ga8fc58fcd95c10cc41d6debcec23c1699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc58fcd95c10cc41d6debcec23c1699">&#9670;&nbsp;</a></span>GDRSA_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDRSA_free </td>
          <td>(</td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#ga4b4cc18f8a0358eca02db69213060195" title="Free a key structure.">GDKey_free()</a>.</dd></dl>
<p>Deallocates resources held by the RSA key structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the RSA key structure to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef3460a3dc46351804c5d49f25f34869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef3460a3dc46351804c5d49f25f34869">&#9670;&nbsp;</a></span>GDRSA_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_sign </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest_algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>digest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>signature_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gacbfe65af0dc09e5b25b68be7272220eb" title="Sign a digest.">GDDigest_sign_final()</a>.</dd></dl>
<p>RSA sign a message digest specified in PKCS #1 v2.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest_algorithm</td><td><code>const GDDigest*</code> the digest algorthim of the message. </td></tr>
    <tr><td class="paramname">digest</td><td><code>const void*</code> a pointer to a buffer containing the message digest. </td></tr>
    <tr><td class="paramname">digest_size</td><td><code>unsigned int</code> the digest size. </td></tr>
    <tr><td class="paramname">signature</td><td><code>void*</code> a pointer to memory large enough to contain the signature. The caller must allocate and eventually free this buffer. The size of the buffer required can be determined by calling <a class="el" href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb" title="RSA modulus size.">GDRSA_size()</a>. </td></tr>
    <tr><td class="paramname">signature_size</td><td><code>unsigned int</code> the number of signature bytes copied to signature. </td></tr>
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the signer's RSA private key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 on success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ga3bcb4c48e92e48b0a5be9db0645ed8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bcb4c48e92e48b0a5be9db0645ed8bc">&#9670;&nbsp;</a></span>GDRSA_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_verify </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__cryptolist.html#ga88753feb89e59dd74163c293c4ec8d83">GDDigest</a> *&#160;</td>
          <td class="paramname"><em>digest_algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>digest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>signature_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd><a class="el" href="group__cryptolist.html#ga627c39856bae844c89ef6c010e05f91a" title="Verify a digest.">GDDigest_verify_final()</a>.</dd></dl>
<p>Verify an RSA signed message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest_algorithm</td><td><code>const GDDigest*</code> denotes the message digest algorithm that was used to generate the signature. </td></tr>
    <tr><td class="paramname">digest</td><td><code>const void*</code> a pointer to a buffer containing the digest of the message to verify. </td></tr>
    <tr><td class="paramname">digest_size</td><td><code>unsigned int</code> the message digest size in bytes. </td></tr>
    <tr><td class="paramname">signature</td><td><code>const void*</code> a pointer to the RSA signature. </td></tr>
    <tr><td class="paramname">signature_size</td><td><code>unsigned int</code> the size of the RSA signature. </td></tr>
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the signer's RSA public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 on successful verification, 0 for failure. The reason for failure can be determined by calling <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga72cadd9241a305d81ff3e34987d54617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72cadd9241a305d81ff3e34987d54617">&#9670;&nbsp;</a></span>GDRSA_public_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_public_encrypt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gab4b1056fdb80168e2514867a9c03f624" title="Encrypt data.">GDKey_encrypt()</a>.</dd></dl>
<p>RSA encrypt a message with the recipient's public key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flen</td><td><code>int</code> the size of the data to be encrypted. </td></tr>
    <tr><td class="paramname">from</td><td><code>const void*</code> a pointer to the data (usually a symmetric key) to be encrypted. </td></tr>
    <tr><td class="paramname">to</td><td><code>void*</code> a pointer to memory large enough to contain the encrypted data. The caller must allocate and eventually free this buffer. The size of the buffer required can be determined by calling <a class="el" href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb" title="RSA modulus size.">GDRSA_size()</a>. </td></tr>
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the recipient's public key. </td></tr>
    <tr><td class="paramname">padding</td><td><code>int</code> the padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> if successful, the size in bytes of the encrypted data, or -1 if not. The reason for failure can be determined by calling <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga70c2b407f98e494dfdfb4064a84eb092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c2b407f98e494dfdfb4064a84eb092">&#9670;&nbsp;</a></span>GDRSA_private_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_private_decrypt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gaf7afd23d01738d6078485997452d8312" title="Decrypt data.">GDKey_decrypt()</a>.</dd></dl>
<p>RSA decrypt a message with the recipient's private key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flen</td><td><code>int</code> the size of the data to be decrypted. </td></tr>
    <tr><td class="paramname">from</td><td><code>const void*</code> a pointer to the data (usually a symmetric key) to be decrypted. </td></tr>
    <tr><td class="paramname">to</td><td><code>void*</code> a pointer to memory large enough to contain the decrypted data. The caller must allocate and eventually free this buffer. The size of the buffer required can be determined by calling <a class="el" href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb" title="RSA modulus size.">GDRSA_size()</a>. </td></tr>
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the recipient's private key. </td></tr>
    <tr><td class="paramname">padding</td><td><code>int</code> the padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> if successful, the size in bytes of the decrypted data, or -1 if not. The reason for failure can be determined by calling <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="gae98ba7cdc1f55471ba9821f5c45ceb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98ba7cdc1f55471ba9821f5c45ceb19">&#9670;&nbsp;</a></span>GDRSA_private_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_private_encrypt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gab4b1056fdb80168e2514867a9c03f624" title="Encrypt data.">GDKey_encrypt()</a>.</dd></dl>
<p>RSA encrypt a message with the recipient's private key. This is a low-level signing operation. To generate an RSA signature, call <a class="el" href="group__cryptolist.html#gaef3460a3dc46351804c5d49f25f34869" title="RSA sign a message digest.">GDRSA_sign()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flen</td><td><code>int</code> the size of the data to be encrypted. </td></tr>
    <tr><td class="paramname">from</td><td><code>const void*</code> a pointer to the data (usually a message digest) to be encrypted. </td></tr>
    <tr><td class="paramname">to</td><td><code>void*</code> a pointer to memory large enough to contain the encrypted data. The caller must allocate and eventually free this buffer. The size of the buffer required can be determined by calling <a class="el" href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb" title="RSA modulus size.">GDRSA_size()</a>. </td></tr>
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the signer's private key. </td></tr>
    <tr><td class="paramname">padding</td><td><code>int</code> the padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> if successful, the size in bytes of the encrypted data, or -1 if not. The reason for failure can be determined by calling <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga9725e3df743e44b9be0ca896613b5acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9725e3df743e44b9be0ca896613b5acf">&#9670;&nbsp;</a></span>GDRSA_public_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDRSA_public_decrypt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct GDRSA *&#160;</td>
          <td class="paramname"><em>rsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__cryptolist.html#gaf7afd23d01738d6078485997452d8312" title="Decrypt data.">GDKey_decrypt()</a>.</dd></dl>
<p>RSA decrypt a message with the sender's public key. This is a low-level verification operation. To verify an RSA signature, call <a class="el" href="group__cryptolist.html#ga3bcb4c48e92e48b0a5be9db0645ed8bc" title="Verify an RSA signed message.">GDRSA_verify()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flen</td><td><code>int</code> the size of the data to be decrypted. </td></tr>
    <tr><td class="paramname">from</td><td><code>const void*</code> a pointer to the data (usually a message digest) to be decrypted. </td></tr>
    <tr><td class="paramname">to</td><td><code>void*</code> a pointer to memory large enough to contain the decrypted data. The caller must allocate and eventually free this buffer. The size of the buffer required can be determined by calling <a class="el" href="group__cryptolist.html#ga185500055c023cbbfd1a6b6bcc2c79fb" title="RSA modulus size.">GDRSA_size()</a>. </td></tr>
    <tr><td class="paramname">rsa</td><td><code>GDRSA*</code> the sender's public key. </td></tr>
    <tr><td class="paramname">padding</td><td><code>int</code> the padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> if successful, the size in bytes of the decrypted data, or -1 if not. The reason for failure can be determined by calling <a class="el" href="group__cryptolist.html#ga1603708f721422f770341800d8a00008" title="Retrieve the earliest error code.">GDCryptoError_get()</a>. </dd></dl>

</div>
</div>
<a id="ga920a5b7c249b272d0b8eb595368c67fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga920a5b7c249b272d0b8eb595368c67fb">&#9670;&nbsp;</a></span>GDStream_mem_storage_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct GDStreamStorageMethod* GDStream_mem_storage_method </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a memory stream storage method required to back a stream object.</p>
<dl class="section return"><dt>Returns</dt><dd><code>GDStream_Method*</code> The stream storage method. If NULL, the storage method is not implemented. </dd></dl>

</div>
</div>
<a id="gaae2df7cc9b9b124eb4fc68206269ab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae2df7cc9b9b124eb4fc68206269ab8d">&#9670;&nbsp;</a></span>GDStream_new_mem_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDStream* GDStream_new_mem_buf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a read-only stream from a small region of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td><code>const void*</code> a pointer to the beginning of the data. </td></tr>
    <tr><td class="paramname">len</td><td><code>int</code> the length of the data, or -1 if the data is null-terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDStream*</code> A read-only memory stream. If NULL, the reason can be obtained from GDCryptoError_get. </dd></dl>

</div>
</div>
<a id="gab94a772f1cb4d7e4a53c02748f98e76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab94a772f1cb4d7e4a53c02748f98e76b">&#9670;&nbsp;</a></span>GDStream_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GDStream* GDStream_new </td>
          <td>(</td>
          <td class="paramtype">const struct GDStreamStorageMethod *&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a stream bakced by the specified storage method. For example, a memory stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td><code>GDStreamStorageMethod*</code> the storage method backing the stream. For example, a memory stream from <a class="el" href="group__cryptolist.html#ga920a5b7c249b272d0b8eb595368c67fb" title="Retrieve a memory stream storage method.">GDStream_mem_storage_method()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>GDStream*</code> A stream of the required storage method. If NULL, the reason can be obtained from GDCryptoError_get. </dd></dl>

</div>
</div>
<a id="ga1caa3ceda70cbf98a26e4cc5bc61838e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1caa3ceda70cbf98a26e4cc5bc61838e">&#9670;&nbsp;</a></span>GDStream_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDStream_read </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a stream and place it into the supplied a buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to read from. </td></tr>
    <tr><td class="paramname">data</td><td><code>void*</code> a pointer to the buffer to place the data into. </td></tr>
    <tr><td class="paramname">len</td><td><code>len</code> length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> The number of bytes read. If -1, the reason can be obtained from GDCryptoError_get. </dd></dl>

</div>
</div>
<a id="ga054f6b119ffe8f96223813029e1be535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054f6b119ffe8f96223813029e1be535">&#9670;&nbsp;</a></span>GDStream_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDStream_write </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data from the supplied buffer, into the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to write to. </td></tr>
    <tr><td class="paramname">data</td><td><code>void*</code> a pointer to the buffer to read the data from. </td></tr>
    <tr><td class="paramname">len</td><td><code>len</code> length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> The number of bytes written. If -1, the reason can be obtained from GDCryptoError_get. </dd></dl>

</div>
</div>
<a id="ga9e2ee36c79c2c80ab0d4fb813e37b364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2ee36c79c2c80ab0d4fb813e37b364">&#9670;&nbsp;</a></span>GDStream_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDStream_reset </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the stream to its initial state by rewinding the pointer to the start of the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 for success. If not 1, the error can be obtained from GDCryptoError_get. </dd></dl>

</div>
</div>
<a id="ga575f45860956e3766fdec7b794e4a0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575f45860956e3766fdec7b794e4a0b1">&#9670;&nbsp;</a></span>GDStream_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDStream_eof </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if the stream has been completely read or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> 1 if EOF has been reached 0 otherwise. </dd></dl>

</div>
</div>
<a id="gae67666c659f796f09bc71f3401a29629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae67666c659f796f09bc71f3401a29629">&#9670;&nbsp;</a></span>GDStream_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDStream_free </td>
          <td>(</td>
          <td class="paramtype">struct GDStream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates resources held by the stream structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><code>GDStream*</code> the stream structure to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga305361f4befc0497771546d3d4d30935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305361f4befc0497771546d3d4d30935">&#9670;&nbsp;</a></span>GDCIPHER_MAX_BLOCK_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDCIPHER_MAX_BLOCK_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum block length for all ciphers. </p>

</div>
</div>
<a id="ga373d4650baaa116ee46cf93b9f30c572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373d4650baaa116ee46cf93b9f30c572">&#9670;&nbsp;</a></span>GDCIPHER_MAX_KEY_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDCIPHER_MAX_KEY_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum key length for all ciphers. </p>

</div>
</div>
<a id="ga38ee68af9f04f1bcd6caf8e2578bf347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ee68af9f04f1bcd6caf8e2578bf347">&#9670;&nbsp;</a></span>GDCIPHER_STREAM_CIPHER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_STREAM_CIPHER</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad0c7e48657fb7601c63822cb7de1caca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c7e48657fb7601c63822cb7de1caca">&#9670;&nbsp;</a></span>GDCIPHER_ECB_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_ECB_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga10b58839eef854a2e8064ee4016abfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b58839eef854a2e8064ee4016abfaa">&#9670;&nbsp;</a></span>GDCIPHER_CBC_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_CBC_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga470781ac90767dc3759b22a1a8a9bf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470781ac90767dc3759b22a1a8a9bf46">&#9670;&nbsp;</a></span>GDCIPHER_CFB_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_CFB_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6a9c2c45f513e4dd57a82b8e7ed16e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a9c2c45f513e4dd57a82b8e7ed16e05">&#9670;&nbsp;</a></span>GDCIPHER_OFB_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_OFB_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad39f4142d3fdf7c642a86c647cd1d800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad39f4142d3fdf7c642a86c647cd1d800">&#9670;&nbsp;</a></span>GDCIPHER_CTR_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_CTR_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa5d0c5fb968590d2a6231f7967cc67df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d0c5fb968590d2a6231f7967cc67df">&#9670;&nbsp;</a></span>GDCIPHER_GCM_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_GCM_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9ba33e186f35166aee6be2c7469aa79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ba33e186f35166aee6be2c7469aa79a">&#9670;&nbsp;</a></span>GDCIPHER_CCM_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_CCM_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab42397bfc2d70e622714097ced8e089a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab42397bfc2d70e622714097ced8e089a">&#9670;&nbsp;</a></span>GDCIPHER_XTS_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_XTS_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae0febb111ba8f63676b7ad7a154479b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0febb111ba8f63676b7ad7a154479b2">&#9670;&nbsp;</a></span>GDCIPHER_WRAP_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long GDCIPHER_WRAP_MODE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6428e5873337845316936f7f7e727aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6428e5873337845316936f7f7e727aac">&#9670;&nbsp;</a></span>GDDIGEST_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDDIGEST_MAX_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maxmium supported digest size in bytes. As of early 2019, this value is 64, which is the size of a SHA-512 digest. </p>

</div>
</div>
<a id="ga6c882911bee25ae0d032f631285e2a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c882911bee25ae0d032f631285e2a03">&#9670;&nbsp;</a></span>GDKEY_TYPE_RSA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDKEY_TYPE_RSA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a RSA (Rivest–Shamir–Adleman) key type. It may be returned when calling <a class="el" href="group__cryptolist.html#ga41a85a056ae70f0840723a057181dd0a" title="Key type.">GDKey_type()</a>. It may also be required for some function calls requiring the key type to be specified. </p>

</div>
</div>
<a id="ga59b999875e8f6a2f8b5fd7406b4233b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59b999875e8f6a2f8b5fd7406b4233b2">&#9670;&nbsp;</a></span>GDKEY_TYPE_DSA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDKEY_TYPE_DSA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a DSA (Digital Signature Algorithm) key type. It may be returned when calling <a class="el" href="group__cryptolist.html#ga41a85a056ae70f0840723a057181dd0a" title="Key type.">GDKey_type()</a>. It may also be required for some function calls requiring the key type to be specified. </p>

</div>
</div>
<a id="gab70c40120b2cf96be15708e789e3c668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab70c40120b2cf96be15708e789e3c668">&#9670;&nbsp;</a></span>GDKEY_TYPE_EC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDKEY_TYPE_EC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a EC (Elliptic Curve) key type. It may be returned when calling <a class="el" href="group__cryptolist.html#ga41a85a056ae70f0840723a057181dd0a" title="Key type.">GDKey_type()</a>. It may also be required for some function calls requiring the key type to be specified. </p>

</div>
</div>
<a id="ga86422d42e837f073526b0bed30c4fe9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86422d42e837f073526b0bed30c4fe9d">&#9670;&nbsp;</a></span>GDPKCS7_TEXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_TEXT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PKCS7 flags to control operations on a PKCS7 structure. These map directly to OpenSSL flags defined in pkcs7.h. Refer to OpenSSL documentation for PKCS7 functions requiring a flag argument for more information. </p>

</div>
</div>
<a id="gafc258a771553b6fbb207a219b21ee85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc258a771553b6fbb207a219b21ee85e">&#9670;&nbsp;</a></span>GDPKCS7_NOCERTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOCERTS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4bf88d5ae48abe9425c218dea063eec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf88d5ae48abe9425c218dea063eec6">&#9670;&nbsp;</a></span>GDPKCS7_NOSIGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOSIGS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac343f9cc25111fd2d4f53f9dc5f21331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac343f9cc25111fd2d4f53f9dc5f21331">&#9670;&nbsp;</a></span>GDPKCS7_NOCHAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOCHAIN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5172cd7fb1b3755868dd182e795bd746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5172cd7fb1b3755868dd182e795bd746">&#9670;&nbsp;</a></span>GDPKCS7_NOINTERN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOINTERN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8e65e23a8d71ebb0db48677308c49293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e65e23a8d71ebb0db48677308c49293">&#9670;&nbsp;</a></span>GDPKCS7_NOVERIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOVERIFY</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga69cd0eeee17335f4f89c2fa29cce6186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69cd0eeee17335f4f89c2fa29cce6186">&#9670;&nbsp;</a></span>GDPKCS7_DETACHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_DETACHED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad34c38e5e513700224d5ef0b92cdfc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad34c38e5e513700224d5ef0b92cdfc37">&#9670;&nbsp;</a></span>GDPKCS7_BINARY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_BINARY</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga44c52d594e9f3ddeb737fc4b99d1fa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c52d594e9f3ddeb737fc4b99d1fa3d">&#9670;&nbsp;</a></span>GDPKCS7_NOATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOATTR</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad67941f4ac6ee59ab4938c78d81cf720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67941f4ac6ee59ab4938c78d81cf720">&#9670;&nbsp;</a></span>GDPKCS7_NOSMIMECAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOSMIMECAP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6bba5519092e74e59de67c9c875d149a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bba5519092e74e59de67c9c875d149a">&#9670;&nbsp;</a></span>GDPKCS7_NOOLDMIMETYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOOLDMIMETYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf1d1f809efe7c428dbe6c0145e18c389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1d1f809efe7c428dbe6c0145e18c389">&#9670;&nbsp;</a></span>GDPKCS7_CRLFEOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_CRLFEOL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga24ea8a6ad476c832ec03bcf2149068b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ea8a6ad476c832ec03bcf2149068b1">&#9670;&nbsp;</a></span>GDPKCS7_STREAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_STREAM</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga79c3574621a6ec61e3ce26127bf2e8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79c3574621a6ec61e3ce26127bf2e8a3">&#9670;&nbsp;</a></span>GDPKCS7_NOCRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_NOCRL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga87d009b78df5f0eb988f1102ba9103e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d009b78df5f0eb988f1102ba9103e2">&#9670;&nbsp;</a></span>GDPKCS7_PARTIAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_PARTIAL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1af3fe8190c9e271c18f68f690445f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1af3fe8190c9e271c18f68f690445f7d">&#9670;&nbsp;</a></span>GDPKCS7_REUSE_DIGEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_REUSE_DIGEST</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae4ab616e169eea6a29785e7731e54d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ab616e169eea6a29785e7731e54d59">&#9670;&nbsp;</a></span>GDPKCS7_USE_KEYID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_USE_KEYID</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga42d89273bb6291fc17468153a683808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d89273bb6291fc17468153a683808b">&#9670;&nbsp;</a></span>GDPKCS7_KEY_PARAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_KEY_PARAM</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga239dbaa148d33cd91242b9cc6abca859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239dbaa148d33cd91242b9cc6abca859">&#9670;&nbsp;</a></span>GDPKCS7_SIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_SIGNED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If returned from <a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb" title="Retrieve the type of PKCS7 structure.">GDPKCS7_type()</a>, PKCS7 structure is signed data. </p>

</div>
</div>
<a id="ga159d697afe2a72fd568e33ab35dcdd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga159d697afe2a72fd568e33ab35dcdd32">&#9670;&nbsp;</a></span>GDPKCS7_ENCRYPTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_ENCRYPTED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If returned from <a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb" title="Retrieve the type of PKCS7 structure.">GDPKCS7_type()</a>, PKCS7 structure is encrypted data. </p>

</div>
</div>
<a id="gabaa13253ed853cca27bccbd01c28ff0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa13253ed853cca27bccbd01c28ff0a">&#9670;&nbsp;</a></span>GDPKCS7_ENVELOPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_ENVELOPED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If returned from <a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb" title="Retrieve the type of PKCS7 structure.">GDPKCS7_type()</a>, PKCS7 structure is enveloped data. </p>

</div>
</div>
<a id="ga76ef9c9fb237a0b07d788c348f1b270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ef9c9fb237a0b07d788c348f1b270c">&#9670;&nbsp;</a></span>GDPKCS7_SIGNED_AND_ENVELOPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_SIGNED_AND_ENVELOPED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If returned from <a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb" title="Retrieve the type of PKCS7 structure.">GDPKCS7_type()</a>, PKCS7 structure is signed and enveloped data. </p>

</div>
</div>
<a id="ga8f35e619be76051f54efd50a52edc589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f35e619be76051f54efd50a52edc589">&#9670;&nbsp;</a></span>GDPKCS7_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_DATA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If returned from <a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb" title="Retrieve the type of PKCS7 structure.">GDPKCS7_type()</a>, PKCS7 structure is data type. </p>

</div>
</div>
<a id="gabf2cac241f7aa392f8cc6ba9ef0257a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf2cac241f7aa392f8cc6ba9ef0257a0">&#9670;&nbsp;</a></span>GDPKCS7_DIGEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDPKCS7_DIGEST</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If returned from <a class="el" href="group__cryptolist.html#ga7860d200df33e48af0064bd5bad459bb" title="Retrieve the type of PKCS7 structure.">GDPKCS7_type()</a>, PKCS7 structure is digest data. </p>

</div>
</div>
<a id="ga6cbabf0cfcec812b7d78baffdbd8d7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cbabf0cfcec812b7d78baffdbd8d7cb">&#9670;&nbsp;</a></span>GDRSA_PKCS1_PADDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDRSA_PKCS1_PADDING</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="_g_d_crypto_key_store_8h.html">GDCryptoKeyStore.h</a> which is a generic API that can handle RSA, DSA, and EC keys.</dd></dl>
<p>Returns a constant representing a PKCS #1 v1.5 padding scheme. </p>

</div>
</div>
<a id="gad31fe9c1ad3e9c599d2173e95792d0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31fe9c1ad3e9c599d2173e95792d0ee">&#9670;&nbsp;</a></span>GDRSA_PKCS1_OAEP_PADDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDRSA_PKCS1_OAEP_PADDING</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Use <a class="el" href="_g_d_crypto_key_store_8h.html">GDCryptoKeyStore.h</a> which is a generic API that can handle RSA, DSA, and EC keys.</dd></dl>
<p>Returns a constant representing a EME-OAEP padding scheme, as defined in PKCS #1 v2.0. </p>

</div>
</div>
<a id="gaad2e013de4862cd9ec628f54cbb8b84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad2e013de4862cd9ec628f54cbb8b84c">&#9670;&nbsp;</a></span>GDRSA_NO_PADDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int GDRSA_NO_PADDING</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Use <a class="el" href="_g_d_crypto_key_store_8h.html">GDCryptoKeyStore.h</a> which is a generic API that can handle RSA, DSA, and EC keys.</dd></dl>
<p>Returns a constant representing no padding scheme. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
Generated Wed Mar 12 2025 12:06:26
with v1.8.17 <a href="http://www.doxygen.org/index.html" target="_blank">doxygen</a >.
Version 13.1.0.48.
© 2025 BlackBerry Limited. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
