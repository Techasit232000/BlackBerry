<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlackBerry Dynamics: Single-Source Push Channel Listener or Delegate</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen_13.1.0.48.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra_13.1.0.48.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="titleheadings">
	<ul> 
		<li id="projectlogo">
	 		<a id="corplink" href="https://blackberry.com/"><img alt="Logo" src="BlackBerryLogo.png"/></a></li>
	 	<li id="projectname">BlackBerry Dynamics</li>
	  	<li id="projectbrief">Runtime library for iOS applications</li>
	  	<li id="projectnumber">13.1.0.48</li>
	 </ul>
	</div>
	 <div id="titlelinks">
	 		<a href="https://developers.blackberry.com">BlackBerry Developers</a>
	 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__ss_push_channel_listener.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Single-Source Push Channel Listener or Delegate</div>  </div>
</div><!--header-->
<div class="contents">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This class is deprecated and will be removed in a future release. Instead of setting a PushChannel delegate, register for notifications as described in the <a class="el" href="interface_g_d_push_channel.html">GDPushChannel </a> class reference.</dd></dl>
<p>State changes that occur when using <a class="el" href="interface_g_d_push_channel.html">GDPushChannel </a> are handled by creating a class that implements this protocol. The callback for handling received Push Channel notifications is also part of this protocol.</p>
<h2>Code Snippets</h2>
<p>The following code snippets illustrate some common tasks. </p><h3>Receive Push Channel Token</h3>
<div class="fragment"><div class="line">-(void)onChannelOpen:(NSString*)token</div>
<div class="line">{</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;onChannelOpen token: %@&quot;</span>, token);</div>
<div class="line">    myApp.pushIsOpen = YES;</div>
<div class="line">    myApp.pushToken = token;</div>
<div class="line">    [myApp sendPushToken];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple <code>onChannelOpen</code> handler. The following takes place when the Push Channel is opened:</p><ul>
<li>The token is logged to the system monitor</li>
<li>The application's channel state is flagged as connected</li>
<li>The token is stored in the application</li>
<li>The application's <code>sendPushToken</code> function is called</li>
</ul>
<p>The <code>sendPushToken</code> function, which would be written by the application developer, would send the token to the application server. This could use a socket, an HTTP request, or another means of communication. From the Push Channel point of view, this is an out-of-band communication.</p>
<p>The server will use the token to address Push Channel notification messages back to the application. These would be received by the application's onChannelMessage handler.</p>
<h3>Receive Push Channel notification</h3>
<div class="fragment"><div class="line">-(void)onChannelMessage:(NSString*)data</div>
<div class="line">{</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;onChannelMessage: %@&quot;</span>, data);</div>
<div class="line">    [myApp processPush:data];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple <code>onChannelMessage</code> handler.</p>
<p>The handler logs the received data to the system monitor, then calls the application <code>processPush</code> function. The "payload" of the notification is passed as a parameter to the <code>processPush</code> function.</p>
<p>The <code>processPush</code> function, which would be written by the application developer, could initiate any of the following actions:</p><ul>
<li>Alert the user that new data is available.</li>
<li>Connect to the application server to retrieve the data. (Connection could use a socket, an HTTP request, or another means of communication. From the Push Channel point of view, this is an out-of-band communication.)</li>
</ul>
<h3>Handle Channel Closure</h3>
<div class="fragment"><div class="line">-(void)onChannelClose:(NSString*)data</div>
<div class="line">{</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;onChannelClose: %@&quot;</span>, data);</div>
<div class="line">    myApp.pushIsOpen = NO;</div>
<div class="line">    [myApp discardPushToken:data];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple <code>onChannelClose</code> handler. The following takes place when the Push Channel is closed:</p><ul>
<li>The token is logged to the system monitor</li>
<li>The application's channel state is flagged as not connected</li>
<li>The application <code>discardPushToken</code> function is called. The token of the closed channel is passed as a parameter.</li>
</ul>
<p>The <code>discardPushToken</code> function would delete the application's copy of the token, possibly after checking that it matches the <code>whichWas</code> parameter. The function could also initiate connection of a new Push Channel, which would have a new token. See <a class="el" href="interface_g_d_push_channel.html#a1396bf9b5defe9fa844a63b5cd40ac0e">connect </a>.</p>
<h3>Handle Channel Error</h3>
<div class="fragment"><div class="line">-(void)onChannelError:(<span class="keywordtype">int</span>)error</div>
<div class="line">{</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;onChannelError: %d&quot;</span>, error);</div>
<div class="line">    myApp.pushIsOpen = NO;</div>
<div class="line">    myApp.pushErr = error;</div>
<div class="line">    [myApp discardPushToken];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple <code>onChannelError</code> handler.</p>
<p>The handler logs the error code to the system monitor, flags the channel's state as not connected, records the error code in the application, then calls the application <code>discardPushToken</code> function.</p>
<p>The <code>discardPushToken</code> function could do any of the following:</p><ul>
<li>Delete the application's copy of the token.</li>
<li>Set the error state in an ongoing status display.</li>
<li>Depending on the error code, initiate connection of a new Push Channel, which would have a new token. See <a class="el" href="interface_g_d_push_channel.html#a1396bf9b5defe9fa844a63b5cd40ac0e">connect </a>.</li>
</ul>
<h3>Handle Ping Failure</h3>
<div class="fragment"><div class="line">-(void)onChannelPingFail:(<span class="keywordtype">int</span>)error</div>
<div class="line">{</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;onChannelPingFail %d&quot;</span>, error);</div>
<div class="line">    <span class="keywordflow">if</span> ( error == 605 ) {</div>
<div class="line">        [myApp resendPushToken];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple <code>onChannelPingFail</code> handler.</p>
<p>The handler logs the error code to the system monitor, then calls the application <code>resendPushToken</code> function if the token was lost.</p>
<p>The <code>resendPushToken</code> function, which would be written by the application developer, would send the application's stored token to the application server. This could use a socket, an HTTP request, or another means of communication. From the Push Channel point of view, this is an out-of-band communication.</p>
<p>The <code>resendPushToken</code> function should expect that the server is not immediately available, perhaps employing a retry policy. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
Generated Wed Mar 12 2025 12:06:26
with v1.8.17 <a href="http://www.doxygen.org/index.html" target="_blank">doxygen</a >.
Version 13.1.0.48.
Â© 2025 BlackBerry Limited. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
