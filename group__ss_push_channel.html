<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlackBerry Dynamics: Single-Source Push Channel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen_13.1.0.48.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra_13.1.0.48.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="titleheadings">
	<ul> 
		<li id="projectlogo">
	 		<a id="corplink" href="https://blackberry.com/"><img alt="Logo" src="BlackBerryLogo.png"/></a></li>
	 	<li id="projectname">BlackBerry Dynamics</li>
	  	<li id="projectbrief">Runtime library for iOS applications</li>
	  	<li id="projectnumber">13.1.0.48</li>
	 </ul>
	</div>
	 <div id="titlelinks">
	 		<a href="https://developers.blackberry.com">BlackBerry Developers</a>
	 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__ss_push_channel.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Single-Source Push Channel</div>  </div>
</div><!--header-->
<div class="contents">
<p>The Push Channel framework is a BlackBerry Dynamics feature used to receive notifications from an application server.</p>
<p>Note that the BlackBerry Dynamics Push Channel feature is not part of the native iOS notification feature set.</p>
<p>Use of the Push Channel feature in the application is dependent on:</p><ul>
<li>Completion of BlackBerry Dynamics authorization processing.</li>
<li>Connection to the BlackBerry Dynamics infrastructure.</li>
</ul>
<p>Push Channel data communication doesn't go via the proxy specified in the native settings of the device or computer on which the application is running, if any.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://docs.blackberry.com/en/endpoint-management/blackberry-uem/" target="_blank">Manuals page for the BlackBerry Dynamics enterprise servers</a> for the Platform Overview. </dd>
<dd>
<a class="el" href="threads.html">Thread support statement</a> </dd>
<dd>
<a class="el" href="background_execution.html">Background Execution</a> </dd>
<dd>
<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/" target="_blank">Local and Remote Notification Programming Guide</a> on the apple.com developer website.</dd></dl>
<h2>Push Channel Usage</h2>
<p>Push Channels are established by the BlackBerry Dynamics application, then used by the application server when needed. The sequence of events is as follows.</p><ol type="1">
<li>The application sets an event handler for Push Channel notifications.</li>
<li>The application requests a Push Channel token from the BlackBerry Dynamics proxy infrastructure.</li>
<li>The application sends the token to its server using, for example, a socket connection or HTTP request.</li>
<li>The application can now wait for a Push Channel notification.<br  />
<br  />
Later, when the server has data for the user, the following steps take place:<br  />
<br  />
</li>
<li>The server sends a Push Channel notification message through the BlackBerry Dynamics proxy infrastructure. The message is addressed using the token.</li>
<li>The message is sent on, and the waiting application's event handler is invoked.<br  />
<br  />
Later, when the server has more data for the user, the following steps take place:<br  />
<br  />
</li>
<li>The server sends another Push Channel notification message through the proxy infrastructure. The message is addressed using the same token.</li>
<li>The message is sent on, and the waiting application's event handler is invoked again.</li>
</ol>
<div class="image">
<img src="sq01 Push Channel.png" alt=""/>
<div class="caption">
Push Channel sequence diagram</div></div>
<p>The BlackBerry Dynamics platform keeps data communications between the application and server alive while the application is waiting for a Push Channel notification. This is achieved by sending "heartbeat" messages at an interval that is dynamically optimized for battery and network performance.</p>
<h2>Ping Failure</h2>
<p>Ping Failure is an optional feature of the Push Channel framework. The application server can register a ping address after receiving the Push Channel token from the mobile application.</p>
<p>If the application server registers a ping address, then it will be periodically checked ("pinged") by the BlackBerry Dynamics Network Operation Center (NOC). If the server does not respond to a ping, then the NOC notifies the application that requested the corresponding Push Channel.</p>
<p>The purpose of this feature is to support servers that lose the Push Channel token when they are restarted.</p>
<p>See the <a class="el" href="_g_n_p.html">Push Channel Back-End API</a> for details of Ping Failure registration.</p>
<h2>Programming Interface</h2>
<p>The Push Channel programming interface is asynchronous and state-based. The application code creates a Push Channel object for each channel it will use, typically one per application server. When a channel changes state, or a channel event occurs, the BlackBerry Dynamics runtime notifies the application.</p>
<h3>Notifications</h3>
<p>To notify the application, the runtime posts an <code>NSNotification</code>.</p>
<p>For all <code>NSNotification</code> instances that are Push Channel notifications:</p><ul>
<li>The object will be the Push Channel object for the channel to which the notification relates.</li>
<li>The name depends on the type of event or change that has occurred. It will be one of the following values.<ul>
<li><a class="el" href="group__pushchannelconstants.html#ga8e79bdad653db4b0570f8c2329ad73a1">GDPushChannelOpenedNotification </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#ga8eef0936afa0c781530e8869596e0dde">GDPushChannelMessageNotification </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#ga1865072365da62e833f294e3a17eefb4">GDPushChannelClosedNotification </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#gace8c053805e9179cb2efd9ee855ce095">GDPushChannelErrorNotification </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#ga80d5a667a818c9509372b88d46b42c26">GDPushChannelPingFailedNotification </a>.</li>
</ul>
</li>
<li>The contents of the user information dictionary, <code>userInfo</code>, depends on the event type. The following values are used as keys.<ul>
<li><a class="el" href="group__pushchannelconstants.html#ga98408e30cd858cd58d53b77f7d77e5ce">GDPushChannelTokenKey </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#ga306decc3dfcb74ff73bb0f90c98a53e6">GDPushChannelHostKey </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#gad9477f336c98cf2f2ae055c975c9116d">GDPushChannelMessageKey </a>.</li>
<li><a class="el" href="group__pushchannelconstants.html#ga84cc4e5c91cfeab020107366148e1bbd">GDPushChannelErrorKey </a>.</li>
</ul>
</li>
</ul>
<p>Push Channel state changes can also be detected by key-value observing (KVO) of the <a class="el" href="interface_g_d_push_channel.html#afb5380ea891b1a2ddfc34bdec08cd574">state </a> property.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank">Key-Value Observing Programming Guide</a> on the apple.com developer website. </dd>
<dd>
<a href="https://developer.apple.com/reference/foundation/nsnotificationcenter" target="_blank">NSNotificationCenter class reference</a> on the apple.com developer website.</dd></dl>
<h3>State cycle</h3>
<p>The availability of functions in the Push Channel programming interface, and what actions take place, are detailed below, and summarized in the following table. The table also summarizes which notifications are expected in each state. </p><table class="doxtable">
<tr>
<th>State </th><th class="th50percent">Functions and actions </th><th class="th35percent">Expected notifications<br  />
 See <a class="el" href="group__pushchannelconstants.html">Push Channel Constants</a>  </th></tr>
<tr>
<td>Prepared </td><td>Application can call <code>connect</code>: state becomes Connecting </td><td>None  </td></tr>
<tr>
<td>Connecting </td><td>BlackBerry Dynamics runtime requests a new channel from the proxy infrastructure </td><td><code>GDPushChannelErrorNotification</code>: new state is Failed<br  />
 <code>GDPushChannelOpenedNotification</code>: new state is Open   </td></tr>
<tr>
<td>Open </td><td>Application can call <code>disconnect</code>: state becomes Disconnecting </td><td><code>GDPushChannelMessageNotification</code>: no state change<br  />
 <code>GDPushChannelPingFailedNotification</code>: no state change<br  />
 <code>GDPushChannelClosedNotification</code>: new state is Disconnected  </td></tr>
<tr>
<td>Disconnecting </td><td>BlackBerry Dynamics Runtime requests the proxy infrastructure to close the channel </td><td><code>GDPushChannelMessageNotification</code>: no state change<br  />
 <code>GDPushChannelPingFailedNotification</code>: no state change<br  />
 <code>GDPushChannelClosedNotification</code>: new state is Disconnected   </td></tr>
<tr>
<td>Disconnected </td><td>Application can call <code>connect</code>: state becomes Connecting </td><td>None  </td></tr>
<tr>
<td>Failed </td><td>Application can call <code>connect</code>: state becomes Connecting </td><td>None  </td></tr>
</table>
<p>The transitions in the above table are also shown in this diagram. </p><div class="image">
<img src="st01 Push Channel.png" alt=""/>
<div class="caption">
Push Channel state transition diagram</div></div>
<p>Note that an individual Push Channel might or might not be closed when the overall Push Channel service becomes unavailable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_n_p.html">Push Channel Back-End API</a></dd></dl>
<h3>Notification feature differences</h3>
<p>The capabilities of the BlackBerry Dynamics Push Channel are different to the capabilities of the native Apple Push Notification Service (APNS) in the following ways.</p>
<p>Only native notifications can be received when the application is in background. This might change in a future release of iOS.</p>
<p>In principle, native notifications alert the user, not the application. Having been alerted, the user may choose to open the application. BlackBerry Dynamics Push Channel messages alert the application, which in turn may alert the user.</p>
<p>BlackBerry Dynamics Push Channel messages can include a "payload" of application data from the server. The application data is conveyed by the proxy infrastructure from the server to the application.</p>
<p>Native notifications may be received whenever the device has a connection to APNS. BlackBerry Dynamics Push Channel messages may be received whenever the application has a connection to the BlackBerry Dynamics infrastructure.</p>
<h2>Push Channel Identifiers</h2>
<p>Every Push Channel must have an identifier. Identifiers must be unique within an application. A Push Channel identifier is a text string set by the application code. Note that Push Channel identifiers aren't the same as Push Channel tokens. Token values are set by the BlackBerry Dynamics infrastructure and runtime.</p>
<p>The following convention represents best practice for Push Channel identifiers.</p>
<p>A Push Channel identifier should be composed of a <em>domain</em> followed by a module <em>name</em> and an optional <em>purpose</em>. The parts are separated by full stops (periods). The following examples illustrate the convention.</p>
<p>Example: <code>com.example.mobile-life.email</code></p><ul>
<li>Domain is "com.example"</li>
<li>Name is "mobile-life"</li>
<li>Purpose is "email"</li>
</ul>
<p>Example: <code>com.example.dashboard</code></p><ul>
<li>Domain is "com.example"</li>
<li>Name is "dashboard"</li>
<li>Purpose is omitted.</li>
</ul>
<p>The rules for identifier part values are as follows.</p><ul>
<li>Domain must be the reversal of an Internet domain that is owned by the developer organisation.</li>
<li>Name must be unique within all the organisation's applications, libraries, and other code modules that might create a Push Channel. Ensuring uniqueness of name values is the responsibility of the developer organisation.</li>
<li>Purpose need only be used in the case that a single application, library, or other code module uses more than one Push Channel. Ensuring uniqueness of purpose values is the responsibility of the code module's developer.</li>
</ul>
<h2>Code Snippets</h2>
<p>The following code snippets illustrate some common tasks. </p><h3>Open Push Channel</h3>
<p>The following snippet shows a Push Channel being created and opened after checking that the service is available. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ([<a class="code" href="interface_g_d_reachability.html">GDReachability</a> sharedInstance].isPushChannelAvailable) {</div>
<div class="line">    NSLog( <span class="stringliteral">@&quot;Push Channel service available&quot;</span>);</div>
<div class="line">    myChannel = [[<a class="code" href="interface_g_d_push_channel.html">GDPushChannel</a> alloc] initWithIdentifier:<span class="stringliteral">@&quot;com.example.dashboard&quot;</span>];</div>
<div class="line">    myHandler = [[AppChannelHandler alloc] init]</div>
<div class="line">    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</div>
<div class="line">    [notificationCenter addObserver:myHandler</div>
<div class="line">                           selector:<span class="keyword">@selector</span>(channelOpenedNotification:)</div>
<div class="line">                               name:<a class="code" href="group__pushchannelconstants.html#ga8e79bdad653db4b0570f8c2329ad73a1">GDPushChannelOpenedNotification</a></div>
<div class="line">                             <span class="keywordtype">object</span>:myChannel];</div>
<div class="line"> </div>
<div class="line">    [notificationCenter addObserver:myHandler</div>
<div class="line">                           selector:<span class="keyword">@selector</span>(channelClosedNotification:)</div>
<div class="line">                               name:<a class="code" href="group__pushchannelconstants.html#ga1865072365da62e833f294e3a17eefb4">GDPushChannelClosedNotification</a></div>
<div class="line">                             <span class="keywordtype">object</span>:myChannel];</div>
<div class="line"> </div>
<div class="line">    [notificationCenter addObserver:myHandler</div>
<div class="line">                           selector:<span class="keyword">@selector</span>(channelErrorNotification:)</div>
<div class="line">                               name:<a class="code" href="group__pushchannelconstants.html#gace8c053805e9179cb2efd9ee855ce095">GDPushChannelErrorNotification</a></div>
<div class="line">                             <span class="keywordtype">object</span>:myChannel];</div>
<div class="line"> </div>
<div class="line">    [notificationCenter addObserver:myHandler</div>
<div class="line">                           selector:<span class="keyword">@selector</span>(channelPingFailedNotification:)</div>
<div class="line">                               name:<a class="code" href="group__pushchannelconstants.html#ga80d5a667a818c9509372b88d46b42c26">GDPushChannelPingFailedNotification</a></div>
<div class="line">                             <span class="keywordtype">object</span>:myChannel];</div>
<div class="line"> </div>
<div class="line">    [notificationCenter addObserver:myHandler</div>
<div class="line">                           selector:<span class="keyword">@selector</span>(channelMessageReceivedNotification:)</div>
<div class="line">                               name:<a class="code" href="group__pushchannelconstants.html#ga8eef0936afa0c781530e8869596e0dde">GDPushChannelMessageNotification</a></div>
<div class="line">                             <span class="keywordtype">object</span>:myChannel];</div>
<div class="line">    [myChannel connect];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows the following taking place:</p><ul>
<li>Availability logged to the system monitor.</li>
<li>Allocation of a Push Channel object.</li>
<li>Allocation of an application Push Channel event handler.</li>
<li>Registration of the new handler for all notifications from the channel. All notifications are sent to the same handler instance, but to different functions, specified as selectors.</li>
<li>Attempt to connect the Push Channel.</li>
</ul>
<p>The attempt is asynchronous. The associated <code>GDPushChannelOpenedNotification</code> notification would be received if and when the attempt is succesful (not shown).</p>
<h3>Close Push Channel</h3>
<div class="fragment"><div class="line">[myChannel disconnect];</div>
</div><!-- fragment --><p> The above snippet shows: Request to disconnect the Push Channel.</p>
<p>The request is asynchronous. The associated <code>GDPushChannelClosedNotification</code> notification would be received when the closure is finalized (not shown).</p>
<h2>Code Snippets</h2>
<p>The following code snippets illustrate some common tasks. </p><h3>Handle Push Channel Opening</h3>
<p>The following snippet shows a simple handler for when a Push Channel opens. </p><div class="fragment"><div class="line">-(void)channelOpenedNotification:(NSNotification *)notification</div>
<div class="line">{</div>
<div class="line">    NSString *token = notification.userInfo[<a class="code" href="group__pushchannelconstants.html#ga98408e30cd858cd58d53b77f7d77e5ce">GDPushChannelTokenKey</a>];</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;GDPushChannelOpenedNotification token: %@&quot;</span>, token);</div>
<div class="line">    NSString *host = notification.userInfo[<a class="code" href="group__pushchannelconstants.html#ga306decc3dfcb74ff73bb0f90c98a53e6">GDPushChannelHostKey</a>];</div>
<div class="line">    <span class="keywordflow">if</span> (host != nil) {</div>
<div class="line">        NSLog(<span class="stringliteral">@&quot;GDPushChannelOpenedNotification push channel host: %@&quot;</span>, host);</div>
<div class="line">        myApp.pushChannelHost = host;</div>
<div class="line">    }</div>
<div class="line">    myApp.pushIsOpen = YES;</div>
<div class="line">    myApp.pushToken = token;</div>
<div class="line">    [myApp sendPushToken];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows the following taking place:</p><ul>
<li>The Push Channel token is extracted from the user information dictionary in the notification.</li>
<li>The token is logged to the system monitor.</li>
<li>The application flags internally that its channel is open, and stores the token value.</li>
<li>The <code>sendPushToken</code> function in the application is called.</li>
</ul>
<p>The <code>sendPushToken</code> function, which would be written by the application developer, would send the token to the application server. This could use a socket, an HTTP request, or another means of communication. From the Push Channel point of view, this is an out-of-band communication.</p>
<p>The server will use the token to address Push Channel notification messages back to the application. These would be received by the application's Push Channel event handler code.</p>
<h3>Receive Push Channel Message</h3>
<div class="fragment"><div class="line">- (void)channelMessageReceivedNotification:(NSNotification *)notification</div>
<div class="line">{</div>
<div class="line">    NSString *data = notification.userInfo[<a class="code" href="group__pushchannelconstants.html#gad9477f336c98cf2f2ae055c975c9116d">GDPushChannelMessageKey</a>];</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;channelMessageReceivedNotification message: %@&quot;</span>, data);</div>
<div class="line">    [myApp processPush:data];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows the following taking place when a Push Channel message is received:</p><ul>
<li>The Push Channel message is extracted from the user information dictionary in the notification.</li>
<li>The message is logged to the system monitor.</li>
<li>The <code>processPush</code> function in the application is called and passed the content of the message.</li>
</ul>
<p>The <code>processPush</code> function, which would be written by the application developer, could initiate any of the following actions:</p><ul>
<li>Alert the user that new data is available.</li>
<li>Connect to the application server to retrieve the data. (Connection could use a socket, an HTTP request, or another means of communication. From the Push Channel point of view, this is an out-of-band communication.)</li>
</ul>
<h3>Handle Channel Closure</h3>
<div class="fragment"><div class="line">-(void)channelClosedNotification:(NSNotification *)notification</div>
<div class="line">{</div>
<div class="line">    NSString *data = notification.userInfo[<a class="code" href="group__pushchannelconstants.html#ga98408e30cd858cd58d53b77f7d77e5ce">GDPushChannelTokenKey</a>];</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;GDPushChannelClosedNotification: %@&quot;</span>, data);</div>
<div class="line">    myApp.pushIsOpen = NO;</div>
<div class="line">    [myApp discardPushToken:data];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple channel closure handler. The following takes place when the Push Channel is closed:</p><ul>
<li>The token is logged to the system monitor.</li>
<li>The application flags internally that its channel isn't open.</li>
<li>The application <code>discardPushToken</code> function is called. The token of the closed channel is passed as a parameter.</li>
</ul>
<p>The <code>discardPushToken</code> function would delete the application's copy of the token, possibly after checking that it matches the previous stored token.</p>
<p>The function could also initiate connection of a new Push Channel, which would have a new token. See <a class="el" href="interface_g_d_push_channel.html#a1396bf9b5defe9fa844a63b5cd40ac0e">connect </a>.</p>
<h3>Handle Channel Error</h3>
<div class="fragment"><div class="line">- (void)channelErrorNotification:(NSNotification *)notification</div>
<div class="line">{</div>
<div class="line">    NSInteger errorCode = [notification[<a class="code" href="group__pushchannelconstants.html#ga84cc4e5c91cfeab020107366148e1bbd">GDPushChannelErrorKey</a>] integerValue];</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;GDPushChannelErrorNotification: %zd&quot;</span>, error);</div>
<div class="line">    myApp.pushIsOpen = NO;</div>
<div class="line">    myApp.pushErr = error;</div>
<div class="line">    [myApp discardPushToken];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple <code>Error</code> handler.</p>
<p>The handler logs the error code to the system monitor, flags the channel's state as not connected, records the error code in the application, then calls the application <code>discardPushToken</code> function.</p>
<p>The <code>discardPushToken</code> function could do any of the following:</p><ul>
<li>Delete the application's copy of the token.</li>
<li>Set the error state in an ongoing status display.</li>
<li>Depending on the error code, initiate connection of a new Push Channel, which would have a new token. See <a class="el" href="interface_g_d_push_channel.html#a1396bf9b5defe9fa844a63b5cd40ac0e">connect </a>.</li>
</ul>
<p>See under Ping Failure in the <a class="el" href="_g_n_p.html">Push Channel Back-End API</a> for an explanation of the Ping Failure feature.</p>
<h3>Handle Ping Failure</h3>
<div class="fragment"><div class="line">- (void)channelErrorNotification:(NSNotification *)notification</div>
<div class="line">{</div>
<div class="line">    NSInteger errorCode = [notification[<a class="code" href="group__pushchannelconstants.html#ga84cc4e5c91cfeab020107366148e1bbd">GDPushChannelErrorKey</a>] integerValue];</div>
<div class="line">    NSLog(<span class="stringliteral">@&quot;GDPushChannelPingFailedNotification %zd&quot;</span>, error);</div>
<div class="line">    <span class="keywordflow">if</span> ( error == 605 ) {</div>
<div class="line">        [myApp resendPushToken];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above snippet shows a simple Ping Failure handler.</p>
<p>The handler logs the error code to the system monitor, then calls the application <code>resendPushToken</code> function if the token was lost.</p>
<p>The <code>resendPushToken</code> function, which would be written by the application developer, would send the application's stored token to the application server. This could use a socket, an HTTP request, or another means of communication. From the Push Channel point of view, this is an out-of-band communication.</p>
<p>The <code>resendPushToken</code> function should expect that the server is not immediately available, perhaps employing a retry policy. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__pushchannelconstants_html_ga8e79bdad653db4b0570f8c2329ad73a1"><div class="ttname"><a href="group__pushchannelconstants.html#ga8e79bdad653db4b0570f8c2329ad73a1">GDPushChannelOpenedNotification</a></div><div class="ttdeci">NSString *const GDPushChannelOpenedNotification</div><div class="ttdoc">Push Channel opened notification name.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_gad9477f336c98cf2f2ae055c975c9116d"><div class="ttname"><a href="group__pushchannelconstants.html#gad9477f336c98cf2f2ae055c975c9116d">GDPushChannelMessageKey</a></div><div class="ttdeci">NSString *const GDPushChannelMessageKey</div><div class="ttdoc">Key for the message data, in a Push Channel notification user information dictionary.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_ga306decc3dfcb74ff73bb0f90c98a53e6"><div class="ttname"><a href="group__pushchannelconstants.html#ga306decc3dfcb74ff73bb0f90c98a53e6">GDPushChannelHostKey</a></div><div class="ttdeci">NSString *const GDPushChannelHostKey</div><div class="ttdoc">Key for the Push Channel host name, in a notification user information dictionary.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_ga1865072365da62e833f294e3a17eefb4"><div class="ttname"><a href="group__pushchannelconstants.html#ga1865072365da62e833f294e3a17eefb4">GDPushChannelClosedNotification</a></div><div class="ttdeci">NSString *const GDPushChannelClosedNotification</div><div class="ttdoc">Push Channel closed notification name.</div></div>
<div class="ttc" id="ainterface_g_d_reachability_html"><div class="ttname"><a href="interface_g_d_reachability.html">GDReachability</a></div><div class="ttdoc">BlackBerry Dynamics infrastructure connection status.</div><div class="ttdef"><b>Definition:</b> GDReachability.h:62</div></div>
<div class="ttc" id="ainterface_g_d_push_channel_html"><div class="ttname"><a href="interface_g_d_push_channel.html">GDPushChannel</a></div><div class="ttdoc">Manage Push Channel tokens and notifications.</div><div class="ttdef"><b>Definition:</b> GDPush.h:384</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_ga84cc4e5c91cfeab020107366148e1bbd"><div class="ttname"><a href="group__pushchannelconstants.html#ga84cc4e5c91cfeab020107366148e1bbd">GDPushChannelErrorKey</a></div><div class="ttdeci">NSString *const GDPushChannelErrorKey</div><div class="ttdoc">Key for the error code, in a Push Channel notification user information dictionary.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_ga80d5a667a818c9509372b88d46b42c26"><div class="ttname"><a href="group__pushchannelconstants.html#ga80d5a667a818c9509372b88d46b42c26">GDPushChannelPingFailedNotification</a></div><div class="ttdeci">NSString *const GDPushChannelPingFailedNotification</div><div class="ttdoc">Push Channel ping failed on server notification name.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_gace8c053805e9179cb2efd9ee855ce095"><div class="ttname"><a href="group__pushchannelconstants.html#gace8c053805e9179cb2efd9ee855ce095">GDPushChannelErrorNotification</a></div><div class="ttdeci">NSString *const GDPushChannelErrorNotification</div><div class="ttdoc">Push Channel error notification name.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_ga8eef0936afa0c781530e8869596e0dde"><div class="ttname"><a href="group__pushchannelconstants.html#ga8eef0936afa0c781530e8869596e0dde">GDPushChannelMessageNotification</a></div><div class="ttdeci">NSString *const GDPushChannelMessageNotification</div><div class="ttdoc">Push Channel received message notification name.</div></div>
<div class="ttc" id="agroup__pushchannelconstants_html_ga98408e30cd858cd58d53b77f7d77e5ce"><div class="ttname"><a href="group__pushchannelconstants.html#ga98408e30cd858cd58d53b77f7d77e5ce">GDPushChannelTokenKey</a></div><div class="ttdeci">NSString *const GDPushChannelTokenKey</div><div class="ttdoc">Key for the Push Channel token, in a notification user information dictionary.</div></div>
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
Generated Wed Mar 12 2025 12:06:26
with v1.8.17 <a href="http://www.doxygen.org/index.html" target="_blank">doxygen</a >.
Version 13.1.0.48.
© 2025 BlackBerry Limited. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
